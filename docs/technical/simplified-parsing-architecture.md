# Tuanki ç®€åŒ–è§£æç³»ç»ŸæŠ€æœ¯æ¶æ„

## ğŸ—ï¸ æ¶æ„æ¦‚è§ˆ

Tuanki ç®€åŒ–è§£æç³»ç»Ÿé‡‡ç”¨åˆ†å±‚æ¶æ„è®¾è®¡ï¼Œå°†è§£æé€»è¾‘ã€é…ç½®ç®¡ç†å’Œç”¨æˆ·ç•Œé¢æ¸…æ™°åˆ†ç¦»ï¼Œç¡®ä¿ç³»ç»Ÿçš„å¯ç»´æŠ¤æ€§å’Œå¯æ‰©å±•æ€§ã€‚

## ğŸ“Š ç³»ç»Ÿæ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ç”¨æˆ·ç•Œé¢å±‚ (UI Layer)                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  SimplifiedParsingSettings.svelte  â”‚  CardCreationModal     â”‚
â”‚  SettingsPanel.svelte              â”‚  StudyModal.svelte     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æœåŠ¡å±‚ (Service Layer)                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  SimplifiedCardParser              â”‚  CardParsingEngine     â”‚
â”‚  ParsingConfigManager              â”‚  ValidationService     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    æ•°æ®å±‚ (Data Layer)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ParsingConfig                     â”‚  CardData              â”‚
â”‚  TemplateDefinition                â”‚  ParseResult           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ æ ¸å¿ƒç»„ä»¶è¯¦è§£

### 1. SimplifiedCardParser

**èŒè´£**ï¼šä¸»è§£æå¼•æ“ï¼Œè´Ÿè´£å°† Markdown å†…å®¹è½¬æ¢ä¸ºå¡ç‰‡æ•°æ®

**æ ¸å¿ƒæ–¹æ³•**ï¼š
```typescript
class SimplifiedCardParser {
  // å•å¡è§£æ
  async parseCard(content: string, config: ParsingConfig): Promise<Card>
  
  // æ‰¹é‡è§£æ
  async parseBatch(content: string, config: ParsingConfig): Promise<Card[]>
  
  // ç±»å‹æ£€æµ‹
  detectCardType(content: string): CardType
  
  // å†…å®¹æå–
  extractFields(content: string, type: CardType): FieldData
}
```

**è§£ææµç¨‹**ï¼š
1. å†…å®¹é¢„å¤„ç†ï¼ˆæ¸…ç†ã€æ ‡å‡†åŒ–ï¼‰
2. å¡ç‰‡ç±»å‹æ£€æµ‹ï¼ˆé—®ç­”ã€é€‰æ‹©ã€æŒ–ç©ºï¼‰
3. å­—æ®µæå–å’Œæ˜ å°„
4. æ•°æ®éªŒè¯å’Œæ¸…ç†
5. å¡ç‰‡å¯¹è±¡æ„å»º

### 2. CardParsingEngine

**èŒè´£**ï¼šè§£æè§„åˆ™å¼•æ“ï¼Œç®¡ç†è§£æé€»è¾‘å’Œé…ç½®

**æ ¸å¿ƒåŠŸèƒ½**ï¼š
```typescript
class CardParsingEngine {
  // é…ç½®ç®¡ç†
  updateConfig(config: Partial<ParsingConfig>): void
  getConfig(): ParsingConfig
  
  // è§„åˆ™ç®¡ç†
  addParsingRule(rule: ParsingRule): void
  removeParsingRule(ruleId: string): void
  
  // æ¨¡æ¿ç®¡ç†
  registerTemplate(template: TemplateDefinition): void
  getTemplate(id: string): TemplateDefinition
}
```

### 3. ParsingConfigManager

**èŒè´£**ï¼šé…ç½®ç®¡ç†å™¨ï¼Œå¤„ç†ç”¨æˆ·è®¾ç½®çš„æŒä¹…åŒ–

**é…ç½®ç»“æ„**ï¼š
```typescript
interface ParsingConfig {
  // è§¦å‘è®¾ç½®
  enableTagTrigger: boolean;
  triggerTag: string;
  
  // ç¬¦å·é…ç½®
  rangeStart: string;
  rangeEnd: string;
  cardDelimiter: string;
  faceDelimiter: string;
  clozeMarker: string;
  
  // è§£æé€‰é¡¹
  preserveFormatting: boolean;
  strictMode: boolean;
  errorHandling: 'skip' | 'warn' | 'fail';
  
  // æ€§èƒ½è®¾ç½®
  maxCardsPerBatch: number;
  parseTimeout: number;
}
```

## ğŸ” è§£æç®—æ³•è¯¦è§£

### å¡ç‰‡ç±»å‹æ£€æµ‹

```typescript
function detectCardType(content: string): CardType {
  // 1. æ£€æµ‹æŒ–ç©ºæ ‡è®°
  if (content.includes('==') && content.match(/==[^=]+==/)) {
    return CardType.CLOZE;
  }
  
  // 2. æ£€æµ‹é€‰æ‹©é¢˜æ ¼å¼
  const choicePattern = /^[\s]*[-*]\s*\[[x\s]\]/m;
  if (choicePattern.test(content)) {
    return CardType.MULTIPLE_CHOICE;
  }
  
  // 3. é»˜è®¤ä¸ºé—®ç­”é¢˜
  return CardType.BASIC_QA;
}
```

### å­—æ®µæå–ç®—æ³•

```typescript
function extractFields(content: string, type: CardType): FieldData {
  const fields: FieldData = {};
  
  switch (type) {
    case CardType.BASIC_QA:
      return extractQAFields(content);
    case CardType.MULTIPLE_CHOICE:
      return extractChoiceFields(content);
    case CardType.CLOZE:
      return extractClozeFields(content);
  }
}

function extractQAFields(content: string): FieldData {
  const dividerIndex = content.indexOf(config.faceDelimiter);
  
  if (dividerIndex !== -1) {
    return {
      front: content.substring(0, dividerIndex).trim(),
      back: content.substring(dividerIndex + config.faceDelimiter.length).trim(),
      tags: extractTags(content)
    };
  } else {
    return {
      front: content.trim(),
      back: '',
      tags: extractTags(content)
    };
  }
}
```

### æ‰¹é‡è§£æç®—æ³•

```typescript
async function parseBatch(content: string): Promise<Card[]> {
  const cards: Card[] = [];
  const ranges = extractRanges(content);
  
  for (const range of ranges) {
    const cardContents = splitCards(range);
    
    for (const cardContent of cardContents) {
      try {
        const card = await parseCard(cardContent);
        cards.push(card);
      } catch (error) {
        handleParsingError(error, cardContent);
      }
    }
  }
  
  return cards;
}
```

## ğŸ¨ ç”¨æˆ·ç•Œé¢ç»„ä»¶

### SimplifiedParsingSettings.svelte

**åŠŸèƒ½**ï¼šè§£æç³»ç»Ÿçš„é…ç½®ç•Œé¢

**ä¸»è¦ç‰¹æ€§**ï¼š
- ç¬¦å·é…ç½®ç®¡ç†
- å®æ—¶é¢„è§ˆåŠŸèƒ½
- æ¨¡æ¿ç¼–è¾‘å™¨
- è§£ææµ‹è¯•å·¥å…·

**ç»„ä»¶ç»“æ„**ï¼š
```svelte
<script lang="ts">
  let config = $state<ParsingConfig>(defaultConfig);
  let previewContent = $state('');
  let parseResult = $state<ParseResult | null>(null);
  
  async function updateConfig(newConfig: Partial<ParsingConfig>) {
    config = { ...config, ...newConfig };
    await saveConfig(config);
    updatePreview();
  }
  
  async function testParsing() {
    const parser = new SimplifiedCardParser();
    parseResult = await parser.parseCard(previewContent, config);
  }
</script>
```

### é…ç½®ç•Œé¢å¸ƒå±€

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¡ç‰‡è§£æè®¾ç½®                                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ â”Œâ”€ åŸºç¡€è®¾ç½® â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ â˜‘ å¯ç”¨æ ‡ç­¾è§¦å‘    è§¦å‘æ ‡ç­¾: [#tuanki        ]         â”‚   â”‚
â”‚ â”‚ â˜‘ ä¿ç•™æ ¼å¼       â˜‘ ä¸¥æ ¼æ¨¡å¼                          â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚ â”Œâ”€ ç¬¦å·é…ç½® â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ æ­£åé¢åˆ†éš”ç¬¦: [---div---    ]                         â”‚   â”‚
â”‚ â”‚ å¡ç‰‡åˆ†éš”ç¬¦:   [---å¡ç‰‡---   ]                         â”‚   â”‚
â”‚ â”‚ æŒ–ç©ºæ ‡è®°:     [==æ–‡æœ¬==     ]                         â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚ â”Œâ”€ è§£ææµ‹è¯• â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚ â”‚ [æµ‹è¯•å†…å®¹è¾“å…¥æ¡†]                                       â”‚   â”‚
â”‚ â”‚ [è§£æç»“æœæ˜¾ç¤º]                                         â”‚   â”‚
â”‚ â”‚                                    [æµ‹è¯•è§£æ] [é‡ç½®]   â”‚   â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸš€ æ€§èƒ½ä¼˜åŒ–

### è§£ææ€§èƒ½ä¼˜åŒ–

1. **æ­£åˆ™è¡¨è¾¾å¼ç¼“å­˜**ï¼š
```typescript
class RegexCache {
  private cache = new Map<string, RegExp>();
  
  getRegex(pattern: string, flags?: string): RegExp {
    const key = `${pattern}:${flags || ''}`;
    if (!this.cache.has(key)) {
      this.cache.set(key, new RegExp(pattern, flags));
    }
    return this.cache.get(key)!;
  }
}
```

2. **å†…å®¹é¢„å¤„ç†ä¼˜åŒ–**ï¼š
```typescript
function preprocessContent(content: string): string {
  // ç§»é™¤ä¸å¿…è¦çš„ç©ºç™½å­—ç¬¦
  content = content.replace(/\r\n/g, '\n');
  content = content.replace(/\n{3,}/g, '\n\n');
  
  // æ ‡å‡†åŒ–æ ‡è®°ç¬¦å·
  content = normalizeMarkers(content);
  
  return content;
}
```

3. **æ‰¹é‡è§£æä¼˜åŒ–**ï¼š
```typescript
async function parseBatchOptimized(contents: string[]): Promise<Card[]> {
  const batchSize = 50;
  const results: Card[] = [];
  
  for (let i = 0; i < contents.length; i += batchSize) {
    const batch = contents.slice(i, i + batchSize);
    const batchResults = await Promise.all(
      batch.map(content => parseCard(content))
    );
    results.push(...batchResults);
  }
  
  return results;
}
```

## ğŸ”’ é”™è¯¯å¤„ç†

### é”™è¯¯ç±»å‹å®šä¹‰

```typescript
enum ParsingErrorType {
  INVALID_FORMAT = 'invalid_format',
  MISSING_CONTENT = 'missing_content',
  REGEX_ERROR = 'regex_error',
  TIMEOUT = 'timeout',
  UNKNOWN = 'unknown'
}

class ParsingError extends Error {
  constructor(
    public type: ParsingErrorType,
    public content: string,
    message: string
  ) {
    super(message);
  }
}
```

### é”™è¯¯å¤„ç†ç­–ç•¥

```typescript
function handleParsingError(error: ParsingError, content: string): void {
  switch (error.type) {
    case ParsingErrorType.INVALID_FORMAT:
      logger.warn(`æ ¼å¼é”™è¯¯: ${error.message}`, { content });
      break;
    case ParsingErrorType.TIMEOUT:
      logger.error(`è§£æè¶…æ—¶: ${error.message}`, { content });
      break;
    default:
      logger.error(`æœªçŸ¥é”™è¯¯: ${error.message}`, { error, content });
  }
}
```

## ğŸ“ˆ æ‰©å±•æ€§è®¾è®¡

### æ’ä»¶åŒ–æ¶æ„

```typescript
interface ParsingPlugin {
  name: string;
  version: string;
  detectCardType?(content: string): CardType | null;
  parseCard?(content: string, config: ParsingConfig): Promise<Card>;
  validateConfig?(config: ParsingConfig): boolean;
}

class PluginManager {
  private plugins: Map<string, ParsingPlugin> = new Map();
  
  registerPlugin(plugin: ParsingPlugin): void {
    this.plugins.set(plugin.name, plugin);
  }
  
  getPlugin(name: string): ParsingPlugin | undefined {
    return this.plugins.get(name);
  }
}
```

### è‡ªå®šä¹‰è§£æè§„åˆ™

```typescript
interface CustomParsingRule {
  id: string;
  name: string;
  pattern: RegExp;
  extractor: (match: RegExpMatchArray) => FieldData;
  validator?: (data: FieldData) => boolean;
}
```

---

**ç‰ˆæœ¬**ï¼šv1.0  
**ç»´æŠ¤çŠ¶æ€**ï¼šæ´»è·ƒå¼€å‘  
**APIç¨³å®šæ€§**ï¼šç¨³å®š
