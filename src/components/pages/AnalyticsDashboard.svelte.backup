<script lang="ts">
  import type AnkiPlugin from "../../main";
  import type { AnkiDataStorage } from "../../data/storage";
  import type { FSRS } from "../../algorithms/fsrs";
  import EnhancedIcon from "../ui/EnhancedIcon.svelte";
  import LineChart from "../analytics/LineChart.svelte";
  import BarChart from "../analytics/BarChart.svelte";
  import Heatmap from "../analytics/Heatmap.svelte";
  import CalendarHeatmap from "../analytics/CalendarHeatmap.svelte";
  import MemoryCurveChart from "../charts/MemoryCurveChart.svelte";
  import DifficultyDistributionChart from "../charts/DifficultyDistributionChart.svelte";
  import ParameterImpactRadar from "../charts/ParameterImpactRadar.svelte";
  import AlgorithmComparisonChart from "../charts/AlgorithmComparisonChart.svelte";
  import FSRSAnalysisPanel from "../analytics/FSRSAnalysisPanel.svelte";
  import VirtualizedDataTable from "../analytics/VirtualizedDataTable.svelte";
  import { AnalyticsService } from "../../data/analytics";
  import type {
    MemoryCurvePoint,
    DifficultyBin,
    ParameterImpact,
    AlgorithmComparisonData,
    FSRSKPIData
  } from "../../data/analytics";

  // å¯¼å…¥é…ç½®å’Œå›½é™…åŒ–
  import { DEFAULT_ANALYTICS_CONFIG, TIME_RANGE_CONFIG, REFRESH_CONFIG, CHART_CONFIG } from "../../config/analytics-config";
  import { i18n } from "../../utils/i18n";
  // import { EnhancedPerformanceMonitor } from "../../utils/enhanced-performance-monitor";
  import { smartRetry, type FallbackStrategy } from "../../utils/smart-retry";
  import { dataPagination } from "../../utils/data-pagination";
  import { smartCache } from "../../utils/smart-cache";
  import { smartPreloader } from "../../utils/smart-preloader";
  import { adaptiveCache } from "../../utils/adaptive-cache";

  interface Props { plugin: AnkiPlugin; dataStorage: AnkiDataStorage; fsrs: FSRS }
  let { plugin, dataStorage, fsrs }: Props = $props();

  // è·å–é…ç½®
  const config = DEFAULT_ANALYTICS_CONFIG;
  const timeRangeConfig = TIME_RANGE_CONFIG;
  const refreshConfig = REFRESH_CONFIG;
  const chartConfig = CHART_CONFIG;

  // æ€§èƒ½ç›‘æ§å®ä¾‹ - æš‚æ—¶ç¦ç”¨ä»¥ä¿®å¤æ„å»º
  // const performanceMonitor = new EnhancedPerformanceMonitor();

  // KPI State
  let isLoading = $state(true);
  let hasError = $state(false);
  let errorMessage = $state('');
  let kpi = $state({
    todayReviews: 0,
    todayNew: 0,
    accuracy: 0,
    totalStudyMins: 0,
    memoryRate: 0,
    streakDays: 0,
    fsrsProgress: 0
  });

  // Load aggregates
  let dayTrend: Array<{ key: string; value: number }> = $state([]);

  // FSRSåˆ†ææ•°æ®çŠ¶æ€
  let memoryCurveData: MemoryCurvePoint[] = $state([]);
  let difficultyData: DifficultyBin[] = $state([]);
  let parameterImpact: ParameterImpact[] = $state([]);
  let algorithmComparison: AlgorithmComparisonData = $state({
    fsrsAccuracy: 0,
    traditionalAccuracy: 0,
    efficiencyGain: 0,
    retentionImprovement: 0,
    sampleSize: 0,
    confidenceLevel: 0
  });
  let fsrsKPI: FSRSKPIData = $state({
    avgDifficulty: 0,
    avgStability: 0,
    retentionRate: 0,
    algorithmEfficiency: 0,
    parameterOptimization: 0,
    totalCards: 0,
    matureCards: 0
  });
  let ratingBars: Array<{ key: string; value: number; color?: string }> = $state([]);
  let hoursMatrix: number[][] = $state([]);
  let calMap: Record<string, number> = $state({});
  let intervalTrend: Array<{ key: string; value: number }> = $state([]);
  let deckCompareData: Array<{ name: string; reviews: number; accuracy: number; avgInterval: number; avgDifficulty: number }> = $state([] as any);
  let range = $state<'7'|'30'|'90'|'year'|'all'>('30');
  let deckOptions = $state<Array<{ id: string; name: string }>>([]);
  let selectedDecks = $state<string[]>([]);
  let deckDdOpen = $state(false);

  const svc = new AnalyticsService(dataStorage);

  function computeRange() {
    const now = new Date();
    if (range==='7') {
      const s=new Date();
      s.setDate(now.getDate() - (timeRangeConfig.PRESETS.WEEK - 1));
      s.setHours(0,0,0,0);
      return { since:s, until: now };
    }
    if (range==='30') {
      const s=new Date();
      s.setDate(now.getDate() - (timeRangeConfig.PRESETS.MONTH - 1));
      s.setHours(0,0,0,0);
      return { since:s, until: now };
    }
    if (range==='90') {
      const s=new Date();
      s.setDate(now.getDate() - (timeRangeConfig.PRESETS.QUARTER - 1));
      s.setHours(0,0,0,0);
      return { since:s, until: now };
    }
    if (range==='year') {
      const s=new Date(now.getFullYear(),0,1);
      return { since:s, until: now };
    }
    return {};
  }

  // é˜²æŠ–å‡½æ•°ï¼Œé¿å…é¢‘ç¹é‡æ–°åŠ è½½
  let reloadTimeout: NodeJS.Timeout | null = null;

  // èµ„æºæ¸…ç†ç®¡ç†
  let cleanupFunctions: (() => void)[] = [];
  let isDestroyed = $state(false);

  // ç¼“å­˜ç»Ÿè®¡çŠ¶æ€
  let cacheStats = $state({
    totalEntries: 0,
    hitRate: 0,
    memoryUsage: 0,
    currentStrategy: 'balanced' as string,
    memoryPressure: 'low' as string,
    accessPatterns: 0
  });

  // ç‰Œç»„å¯¹æ¯”è¡¨æ ¼åˆ—é…ç½®
  const deckTableColumns = [
    {
      key: 'name',
      title: i18n.t('analytics.dashboard.table.deck'),
      width: '30%',
      align: 'left' as const,
      sortable: true
    },
    {
      key: 'reviews',
      title: i18n.t('analytics.dashboard.table.reviews'),
      width: '20%',
      align: 'right' as const,
      sortable: true,
      formatter: (value: number) => value.toLocaleString()
    },
    {
      key: 'accuracy',
      title: i18n.t('analytics.dashboard.table.accuracy'),
      width: '20%',
      align: 'right' as const,
      sortable: true,
      formatter: (value: number) => `${(value * 100).toFixed(1)}%`
    },
    {
      key: 'avgInterval',
      title: i18n.t('analytics.dashboard.table.avgInterval'),
      width: '15%',
      align: 'right' as const,
      sortable: true,
      formatter: (value: number) => `${value.toFixed(1)}å¤©`
    },
    {
      key: 'avgDifficulty',
      title: i18n.t('analytics.dashboard.table.avgDifficulty'),
      width: '15%',
      align: 'right' as const,
      sortable: true,
      formatter: (value: number) => value.toFixed(2)
    }
  ];

  /**
   * æ·»åŠ æ¸…ç†å‡½æ•°
   */
  function addCleanup(cleanup: () => void): void {
    if (!isDestroyed) {
      cleanupFunctions.push(cleanup);
    }
  }

  /**
   * æ¸…ç†å¤§æ•°æ®é›†
   */
  function clearLargeDataSets(): void {
    dayTrend = [];
    ratingBars = [];
    hoursMatrix = [];
    calMap = {};
    intervalTrend = [];
    deckCompareData = [];
    memoryCurveData = [];
    difficultyData = [];
    parameterImpact = [];

    // é‡ç½®FSRSæ•°æ®
    algorithmComparison = {
      fsrsAccuracy: 0,
      traditionalAccuracy: 0,
      efficiencyGain: 0,
      retentionImprovement: 0,
      sampleSize: 0,
      confidenceLevel: 0
    };

    fsrsKPI = {
      avgDifficulty: 0,
      avgStability: 0,
      retentionRate: 0,
      algorithmEfficiency: 0,
      parameterOptimization: 0,
      totalCards: 0,
      matureCards: 0
    };
  }

  /**
   * æ•°æ®é‡‡æ ·ä¼˜åŒ– - é¿å…å¤„ç†è¿‡å¤§çš„æ•°æ®é›†
   */
  function sampleData<T>(data: T[], maxSize: number): T[] {
    if (!Array.isArray(data) || data.length <= maxSize) return data;

    // ä½¿ç”¨æ™ºèƒ½é‡‡æ ·ç­–ç•¥
    return dataPagination.smartSample(data, maxSize, 'uniform');
  }

  /**
   * æ‰¹é‡å¤„ç†å¤§æ•°æ®é›†
   */
  async function processBatchData<T, R>(
    data: T[],
    processor: (batch: T[]) => Promise<R[]>,
    onProgress?: (processed: number, total: number) => void
  ): Promise<R[]> {
    if (data.length <= config.performance.BATCH_PROCESSING.CHUNK_SIZE) {
      return processor(data);
    }

    const result = await dataPagination.processBatches(
      data,
      processor,
      {
        batchSize: config.performance.BATCH_PROCESSING.CHUNK_SIZE,
        processingDelay: config.performance.BATCH_PROCESSING.PROCESSING_DELAY,
        maxConcurrent: config.performance.BATCH_PROCESSING.MAX_CONCURRENT,
        onProgress,
        onBatchComplete: (batchIndex, batchData) => {
          console.log(`ğŸ“Š Processed batch ${batchIndex + 1}, items: ${batchData.length}`);
        }
      }
    );

    return result.processedData;
  }

  /**
   * éªŒè¯å’Œæ¸…ç†æ•°æ®
   */
  function validateAndCleanData<T extends Record<string, any>>(
    data: T[],
    requiredFields: string[]
  ): T[] {
    if (!Array.isArray(data)) return [];

    return data.filter(item => {
      if (!item || typeof item !== 'object') return false;

      // æ£€æŸ¥å¿…éœ€å­—æ®µ
      for (const field of requiredFields) {
        if (!(field in item)) return false;
      }

      return true;
    });
  }

  /**
   * æ£€æŸ¥æ•°æ®å®Œæ•´æ€§
   */
  function checkDataIntegrity(data: any[], minDataPoints: number = 1): boolean {
    if (!Array.isArray(data) || data.length < minDataPoints) {
      return false;
    }

    const validItems = data.filter(item => item != null);
    const missingRatio = (data.length - validItems.length) / data.length;

    return missingRatio <= config.validation.DATA_INTEGRITY.MAX_MISSING_RATIO;
  }

  /**
   * æ‰§è¡Œæ‰€æœ‰æ¸…ç†æ“ä½œ
   */
  function performCleanup(): void {
    if (isDestroyed) return;

    isDestroyed = true;

    // æ¸…ç†å®šæ—¶å™¨
    if (reloadTimeout) {
      clearTimeout(reloadTimeout);
      reloadTimeout = null;
    }

    // æ¸…ç†å¤§æ•°æ®é›†
    clearLargeDataSets();

    // æ‰§è¡Œæ‰€æœ‰æ³¨å†Œçš„æ¸…ç†å‡½æ•°
    cleanupFunctions.forEach(cleanup => {
      try {
        cleanup();
      } catch (error) {
        console.error('Error during cleanup:', error);
      }
    });

    cleanupFunctions = [];
  }

  // å†…å­˜ç›‘æ§ã€ç¼“å­˜é¢„åŠ è½½å’Œè‡ªåŠ¨æ¸…ç†
  $effect(() => {
    // è®¾ç½®æ™ºèƒ½é¢„åŠ è½½è§„åˆ™
    smartPreloader.addPreloadRule({
      name: 'analytics-range-preload',
      priority: 10,
      confidence: 0.9,
      trigger: (pattern) => pattern.action === 'range-change',
      predictor: (pattern) => {
        const currentRange = pattern.context.toRange;
        const adjacentRanges = [];

        if (currentRange === '7') adjacentRanges.push('30');
        if (currentRange === '30') adjacentRanges.push('7', '90');
        if (currentRange === '90') adjacentRanges.push('30', 'year');
        if (currentRange === 'year') adjacentRanges.push('90');

        return adjacentRanges.map(r => `analytics-data-${r}-${JSON.stringify(selectedDecks)}`);
      },
      loader: async (keys) => {
        // è¿™é‡Œå¯ä»¥å®ç°å®é™…çš„æ•°æ®é¢„åŠ è½½é€»è¾‘
        console.log('ğŸš€ Preloading analytics data for keys:', keys);
        return {};
      }
    });

    // è®¾ç½®ç‰Œç»„é€‰æ‹©é¢„åŠ è½½è§„åˆ™
    smartPreloader.addPreloadRule({
      name: 'deck-selection-preload',
      priority: 8,
      confidence: 0.7,
      trigger: (pattern) => pattern.action === 'deck-toggle',
      predictor: (pattern) => {
        // é¢„æµ‹ç”¨æˆ·å¯èƒ½é€‰æ‹©çš„ç›¸å…³ç‰Œç»„æˆ–åˆ‡æ¢æ—¶é—´èŒƒå›´
        const predictions = [];

        // å¦‚æœç”¨æˆ·é€‰æ‹©äº†å¤šä¸ªç‰Œç»„ï¼Œå¯èƒ½ä¼šæŸ¥çœ‹ä¸åŒæ—¶é—´èŒƒå›´
        if (pattern.context.selectedDecks && pattern.context.selectedDecks.length > 1) {
          predictions.push(`analytics-data-7-${JSON.stringify(pattern.context.selectedDecks)}`);
          predictions.push(`analytics-data-30-${JSON.stringify(pattern.context.selectedDecks)}`);
        }

        return predictions;
      },
      loader: async (keys) => {
        console.log('ğŸš€ Preloading deck-related data for keys:', keys);
        return {};
      }
    });

    // è®¾ç½®å®šæœŸå†…å­˜æ£€æŸ¥å’Œç¼“å­˜ç»Ÿè®¡æ›´æ–°
    const memoryCheckInterval = setInterval(() => {
      if (isDestroyed) return;

      // æ›´æ–°ç¼“å­˜ç»Ÿè®¡
      const stats = smartCache.getStats();
      const adaptiveStats = adaptiveCache.getAdaptiveStats();
      cacheStats = {
        totalEntries: stats.totalEntries,
        hitRate: stats.hitRate,
        memoryUsage: stats.memoryUsage,
        currentStrategy: adaptiveStats.currentStrategy,
        memoryPressure: adaptiveStats.memoryPressure.level,
        accessPatterns: adaptiveStats.accessPatterns
      };

      // æ£€æŸ¥å†…å­˜ä½¿ç”¨æƒ…å†µ
      if ('memory' in performance) {
        const memInfo = (performance as any).memory;
        const usedMB = memInfo.usedJSHeapSize / (1024 * 1024);

        // å¦‚æœå†…å­˜ä½¿ç”¨è¶…è¿‡é˜ˆå€¼ï¼Œè§¦å‘æ¸…ç†
        if (usedMB > config.performance.CACHE.MAX_SIZE) {
          console.warn(`Memory usage high: ${usedMB.toFixed(1)}MB, triggering cleanup`);
          clearLargeDataSets();
          smartCache.deleteByTag('preloaded'); // æ¸…ç†é¢„åŠ è½½çš„ç¼“å­˜
        }
      }
    }, config.performance.CACHE.CLEANUP_INTERVAL);

    addCleanup(() => {
      clearInterval(memoryCheckInterval);
      smartCache.clear(); // æ¸…ç†æ‰€æœ‰ç¼“å­˜
      smartPreloader.clearHistory(); // æ¸…ç†é¢„åŠ è½½å†å²
      adaptiveCache.destroy(); // æ¸…ç†è‡ªé€‚åº”ç¼“å­˜
    });

    return () => {
      performCleanup();
    };
  });

  async function reloadCharts() {
    if (isDestroyed) return;

    if (reloadTimeout) {
      clearTimeout(reloadTimeout);
    }

    reloadTimeout = setTimeout(async () => {
      if (isDestroyed) return;

      try {
        // å¼€å§‹æ€§èƒ½ç›‘æ§ - æš‚æ—¶ç¦ç”¨
        // performanceMonitor.startMeasure('analytics-dashboard-load', {
        //   range,
        //   selectedDecks: selectedDecks.length,
        //   timestamp: Date.now()
        // });

        isLoading = true;
        hasError = false;
        errorMessage = '';

        // åœ¨åŠ è½½æ–°æ•°æ®å‰æ¸…ç†æ—§æ•°æ®ä»¥é‡Šæ”¾å†…å­˜
        clearLargeDataSets();

        const f = { ...computeRange(), deckIds: selectedDecks.length ? selectedDecks : undefined } as any;

        // å¼€å§‹æ•°æ®åŠ è½½æ€§èƒ½ç›‘æ§ - æš‚æ—¶ç¦ç”¨
        // performanceMonitor.startMeasure('analytics-data-load', {
        //   operation: 'parallel-data-fetch',
        //   dataPoints: 11
        // });

        // å®šä¹‰é™çº§ç­–ç•¥
        const fallbackStrategies: FallbackStrategy<any[]>[] = [
          {
            name: 'reduced-data-set',
            priority: 1,
            execute: async () => {
              // é™çº§ç­–ç•¥ï¼šåªåŠ è½½æ ¸å¿ƒæ•°æ®
              console.log('ğŸ”„ Using reduced data set fallback');
              return Promise.all([
                svc.trend('day', 7, f), // å‡å°‘åˆ°7å¤©
                svc.ratingDistribution(f),
                [], // è·³è¿‡å°æ—¶çŸ©é˜µ
                {}, // è·³è¿‡æ—¥å†çƒ­åŠ›å›¾
                [], // è·³è¿‡é—´éš”å¢é•¿
                svc.deckCompare(f),
                [], // è·³è¿‡FSRSæ•°æ®
                [],
                [],
                { fsrsAccuracy: 0, traditionalAccuracy: 0, efficiencyGain: 0, retentionImprovement: 0, sampleSize: 0, confidenceLevel: 0 },
                { avgDifficulty: 0, avgStability: 0, retentionRate: 0, algorithmEfficiency: 0, parameterOptimization: 0, totalCards: 0, matureCards: 0 }
              ]);
            }
          },
          {
            name: 'minimal-data-set',
            priority: 2,
            execute: async () => {
              // æœ€å°æ•°æ®é›†ï¼šåªåŠ è½½åŸºæœ¬ç»Ÿè®¡
              console.log('ğŸ”„ Using minimal data set fallback');
              return Promise.all([
                svc.trend('day', 3, f), // åªåŠ è½½3å¤©
                svc.ratingDistribution(f),
                [], [], [], [],
                [], [], [],
                { fsrsAccuracy: 0, traditionalAccuracy: 0, efficiencyGain: 0, retentionImprovement: 0, sampleSize: 0, confidenceLevel: 0 },
                { avgDifficulty: 0, avgStability: 0, retentionRate: 0, algorithmEfficiency: 0, parameterOptimization: 0, totalCards: 0, matureCards: 0 }
              ]);
            }
          }
        ];

        // ç”Ÿæˆç¼“å­˜é”®
        const cacheKey = `analytics-data-${range}-${JSON.stringify(selectedDecks)}-${Date.now() - (Date.now() % (5 * 60 * 1000))}`; // 5åˆ†é’Ÿç¼“å­˜çª—å£

        // è®°å½•è®¿é—®æ¨¡å¼ç”¨äºè‡ªé€‚åº”ç¼“å­˜
        adaptiveCache.recordAccess(cacheKey, 0); // æ•°æ®å¤§å°å°†åœ¨åŠ è½½åæ›´æ–°

        // è·å–è‡ªé€‚åº”ç¼“å­˜å»ºè®®
        const cacheRecommendation = adaptiveCache.getCacheRecommendation(cacheKey, 1024 * 1024); // ä¼°ç®—1MBæ•°æ®

        // ä½¿ç”¨æ™ºèƒ½ç¼“å­˜å’Œé‡è¯•ç­–ç•¥åŠ è½½æ•°æ®
        const dataLoadResult = await smartCache.getOrSet(
          cacheKey,
          async () => {
            const result = await smartRetry.executeWithFallback(
              async () => {
                // ä¸»è¦æ•°æ®åŠ è½½æ“ä½œ
                return Promise.all([
                  svc.trend('day', timeRangeConfig.DEFAULT_DAYS, f),
                  svc.ratingDistribution(f),
                  svc.hourWeekMatrix(f),
                  svc.calendarHeat(new Date().getFullYear(), f),
                  svc.intervalGrowth('week', f),
                  svc.deckCompare(f),
                  // FSRSåˆ†ææ•°æ®åŠ è½½
                  svc.getMemoryCurveData(f),
                  svc.getDifficultyDistribution(f),
                  svc.getParameterImpactAnalysis(f),
                  svc.getAlgorithmComparison(f),
                  svc.getFSRSKPIData(f)
                ]);
              },
              fallbackStrategies,
              {
                maxAttempts: 3,
                initialDelay: 1000,
                onRetry: (attempt, error) => {
                  console.warn(`ğŸ“Š Analytics data load retry ${attempt}:`, error.message);
                }
              }
            );

            // æ›´æ–°è®¿é—®æ¨¡å¼çš„æ•°æ®å¤§å°
            const dataSize = JSON.stringify(result).length * 2; // ä¼°ç®—å­—èŠ‚æ•°
            adaptiveCache.recordAccess(cacheKey, dataSize);

            return result;
          },
          cacheRecommendation.shouldCache ? cacheRecommendation.ttl : config.performance.CACHE.TTL,
          ['analytics', `range-${range}`, 'dashboard-data']
        );

        // å¤„ç†ç¼“å­˜æˆ–æ–°åŠ è½½çš„æ•°æ®
        let actualData;
        if (dataLoadResult && typeof dataLoadResult === 'object' && 'success' in dataLoadResult) {
          // è¿™æ˜¯ä»é‡è¯•ç³»ç»Ÿè¿”å›çš„ç»“æœ
          if (!dataLoadResult.success) {
            throw dataLoadResult.error;
          }
          actualData = dataLoadResult.data!;

          // è®°å½•ä½¿ç”¨çš„ç­–ç•¥
          if (dataLoadResult.strategy !== 'primary') {
            console.warn(`ğŸ“Š Analytics loaded using fallback strategy: ${dataLoadResult.strategy}`);
          }
        } else {
          // è¿™æ˜¯ä»ç¼“å­˜è¿”å›çš„ç›´æ¥æ•°æ®
          actualData = dataLoadResult;
          console.log('ğŸ“¦ Analytics data loaded from cache');
        }

        const [
          trendData,
          ratingData,
          hoursData,
          calendarData,
          intervalData,
          deckData,
          memoryCurve,
          difficultyDist,
          parameterAnalysis,
          algorithmComp,
          fsrsKPIData
        ] = actualData;

        // ç»“æŸæ•°æ®åŠ è½½ç›‘æ§ - æš‚æ—¶ç¦ç”¨
        // const dataLoadDuration = performanceMonitor.endMeasure('analytics-data-load');
        // console.log(`ğŸ“Š Analytics data loaded in ${dataLoadDuration?.toFixed(2)}ms`);

        // å¼€å§‹æ•°æ®å¤„ç†æ€§èƒ½ç›‘æ§ - æš‚æ—¶ç¦ç”¨
        // performanceMonitor.startMeasure('analytics-data-processing', {
        //   operation: 'data-validation-and-transformation',
        //   trendDataSize: trendData?.length || 0,
        //   ratingDataSize: ratingData?.length || 0
        // });

        // æ•°æ®è½¬æ¢å’ŒéªŒè¯ï¼Œåº”ç”¨é‡‡æ ·ä¼˜åŒ–
        try {
          // éªŒè¯å’Œå¤„ç†è¶‹åŠ¿æ•°æ®ï¼Œä½¿ç”¨æ‰¹é‡å¤„ç†
          const validTrendData = validateAndCleanData(trendData, ['key']);
          if (checkDataIntegrity(validTrendData, config.validation.DATA_INTEGRITY.MIN_DATA_POINTS)) {
            if (validTrendData.length > config.performance.BATCH_PROCESSING.CHUNK_SIZE) {
              console.log(`ğŸ“Š Processing large trend dataset: ${validTrendData.length} items`);
              const processedTrendData = await processBatchData(
                validTrendData,
                async (batch) => {
                  return batch.map(p => ({
                    key: p.key,
                    value: Math.max(0, p.reviews || 0)
                  }));
                },
                (processed, total) => {
                  console.log(`ğŸ“Š Trend data processing: ${processed}/${total}`);
                }
              );
              dayTrend = sampleData(processedTrendData, config.performance.SAMPLING.MAX_REVIEWS_SAMPLE);
            } else {
              const sampledTrendData = sampleData(validTrendData, config.performance.SAMPLING.MAX_REVIEWS_SAMPLE);
              dayTrend = sampledTrendData.map(p => ({
                key: p.key,
                value: Math.max(0, p.reviews || 0)
              }));
            }
          } else {
            console.warn('Trend data integrity check failed');
            dayTrend = [];
          }

          // éªŒè¯å’Œå¤„ç†è¯„åˆ†æ•°æ®
          const validRatingData = validateAndCleanData(ratingData, ['rating']);
          ratingBars = validRatingData.map((r, i) => ({
            key: String(r.rating),
            value: Math.max(0, r.count || 0),
            color: [chartConfig.COLORS.ERROR, chartConfig.COLORS.WARNING, chartConfig.COLORS.SUCCESS, chartConfig.COLORS.PRIMARY][i] || chartConfig.COLORS.SECONDARY
          }));

          // éªŒè¯çƒ­åŠ›å›¾æ•°æ®
          if (Array.isArray(hoursData) && hoursData.every(row => Array.isArray(row))) {
            hoursMatrix = hoursData;
          } else {
            console.warn('Hours matrix data is invalid');
            hoursMatrix = [];
          }

          // éªŒè¯æ—¥å†æ•°æ®
          if (calendarData && typeof calendarData === 'object') {
            calMap = calendarData;
          } else {
            console.warn('Calendar data is invalid');
            calMap = {};
          }

          // éªŒè¯å’Œå¤„ç†é—´éš”æ•°æ®
          const validIntervalData = validateAndCleanData(intervalData, ['key']);
          if (checkDataIntegrity(validIntervalData)) {
            const sampledIntervalData = sampleData(validIntervalData, config.performance.SAMPLING.MAX_REVIEWS_SAMPLE);
            intervalTrend = sampledIntervalData.map(p => ({
              key: p.key,
              value: Math.max(0, Math.min(100, p.accuracy || 0))
            }));
          } else {
            intervalTrend = [];
          }

          // éªŒè¯ç‰Œç»„å¯¹æ¯”æ•°æ®
          const validDeckData = validateAndCleanData(deckData, ['name']);
          deckCompareData = sampleData(validDeckData, 20).map(deck => ({
            name: deck.name || 'Unknown',
            reviews: deck.reviews || 0,
            accuracy: deck.accuracy || 0,
            avgInterval: deck.avgInterval || 0,
            avgDifficulty: deck.avgDifficulty || 0
          }));

          // FSRSæ•°æ®éªŒè¯å’Œèµ‹å€¼ï¼Œä½¿ç”¨æ‰¹é‡å¤„ç†ä¼˜åŒ–
          if (Array.isArray(memoryCurve)) {
            // å¯¹å¤§æ•°æ®é›†ä½¿ç”¨æ‰¹é‡å¤„ç†
            if (memoryCurve.length > config.performance.BATCH_PROCESSING.CHUNK_SIZE) {
              console.log(`ğŸ“Š Processing large memory curve dataset: ${memoryCurve.length} items`);
              memoryCurveData = await processBatchData(
                memoryCurve,
                async (batch) => {
                  // æ‰¹é‡éªŒè¯å’Œå¤„ç†å†…å­˜æ›²çº¿æ•°æ®
                  return batch.filter(item => item && typeof item === 'object');
                },
                (processed, total) => {
                  console.log(`ğŸ“Š Memory curve processing: ${processed}/${total}`);
                }
              );
              memoryCurveData = sampleData(memoryCurveData, config.performance.SAMPLING.MAX_CARDS_SAMPLE);
            } else {
              memoryCurveData = sampleData(memoryCurve, config.performance.SAMPLING.MAX_CARDS_SAMPLE);
            }
          } else {
            memoryCurveData = [];
          }

          if (Array.isArray(difficultyDist)) {
            difficultyData = sampleData(difficultyDist, 50);
          } else {
            difficultyData = [];
          }

          if (Array.isArray(parameterAnalysis)) {
            parameterImpact = sampleData(parameterAnalysis, 30);
          } else {
            parameterImpact = [];
          }

          algorithmComparison = algorithmComp || {
            fsrsAccuracy: 0,
            traditionalAccuracy: 0,
            efficiencyGain: 0,
            retentionImprovement: 0,
            sampleSize: 0,
            confidenceLevel: 0
          };

          fsrsKPI = fsrsKPIData || {
            avgDifficulty: 0,
            avgStability: 0,
            retentionRate: 0,
            algorithmEfficiency: 0,
            parameterOptimization: 0,
            totalCards: 0,
            matureCards: 0
          };

        } catch (dataError) {
          console.error('Error processing chart data:', dataError);
          // performanceMonitor.reportError(dataError as Error, 'analytics-data-processing');

          // è®¾ç½®é»˜è®¤ç©ºæ•°æ®
          dayTrend = [];
          ratingBars = [];
          hoursMatrix = [];
          calMap = {};
          intervalTrend = [];
          deckCompareData = [];
          memoryCurveData = [];
          difficultyData = [];
          parameterImpact = [];
        } finally {
          // ç»“æŸæ•°æ®å¤„ç†ç›‘æ§ - æš‚æ—¶ç¦ç”¨
          // const processingDuration = performanceMonitor.endMeasure('analytics-data-processing');
          // console.log(`ğŸ”„ Analytics data processed in ${processingDuration?.toFixed(2)}ms`);
        }
      } catch (error) {
        console.error('Error reloading charts:', error);
        // performanceMonitor.reportError(error as Error, 'analytics-dashboard-load');
        hasError = true;

        // ä½¿ç”¨æ™ºèƒ½é‡è¯•æœåŠ¡ç”Ÿæˆç”¨æˆ·å‹å¥½çš„é”™è¯¯æ¶ˆæ¯
        errorMessage = smartRetry.createUserFriendlyMessage(error as Error, 'æ•°æ®åŠ è½½');

        // è·å–æ¢å¤å»ºè®®ï¼ˆå¯ä»¥åœ¨UIä¸­æ˜¾ç¤ºï¼‰
        const suggestions = smartRetry.getRecoverySuggestions(error as Error);
        console.log('Recovery suggestions:', suggestions);
      } finally {
        isLoading = false;

        // ç»“æŸæ€»ä½“åŠ è½½ç›‘æ§ - æš‚æ—¶ç¦ç”¨
        // const totalDuration = performanceMonitor.endMeasure('analytics-dashboard-load');
        // console.log(`ğŸ“ˆ Analytics dashboard loaded in ${totalDuration?.toFixed(2)}ms`);

        // è®°å½•å†…å­˜ä½¿ç”¨æƒ…å†µ
        if ('memory' in performance) {
          const memInfo = (performance as any).memory;
          const usedMB = memInfo.usedJSHeapSize / (1024 * 1024);
          console.log(`ğŸ’¾ Memory usage: ${usedMB.toFixed(1)}MB`);
        }
      }
    }, refreshConfig.DEBOUNCE_DELAY);
  }

  (async () => {
    isLoading = true;
    hasError = false;
    errorMessage = '';

    try {
      // ä½¿ç”¨æ™ºèƒ½é‡è¯•åŠ è½½åŸºç¡€æ•°æ®
      const [cards, decks] = await smartRetry.executeWithRetry(
        async () => {
          const result = await Promise.all([
            dataStorage.getCards(),
            dataStorage.getDecks()
          ]);

          if (!Array.isArray(result[0]) || !Array.isArray(result[1])) {
            throw new Error(i18n.t('analytics.errors.dataCorrupted'));
          }

          return result;
        },
        {
          maxAttempts: 3,
          initialDelay: 500,
          onRetry: (attempt, error) => {
            console.warn(`ğŸ“Š Initial data load retry ${attempt}:`, error.message);
          }
        }
      );

      deckOptions = decks.map(d => ({ id: d.id, name: d.name }));

      // ä½¿ç”¨æ™ºèƒ½é‡è¯•è·å–å­¦ä¹ ä¼šè¯æ•°æ®
      const sessions = await smartRetry.executeWithRetry(
        async () => {
          const result = await dataStorage.getStudySessions();
          if (!Array.isArray(result)) {
            throw new Error(i18n.t('analytics.errors.dataCorrupted'));
          }
          return result;
        },
        {
          maxAttempts: 2,
          initialDelay: 300,
          onRetry: (attempt, error) => {
            console.warn(`ğŸ“Š Sessions data load retry ${attempt}:`, error.message);
          }
        }
      );

      const today = new Date(); today.setHours(0,0,0,0);
      const isToday = (d: Date) => new Date(d).getTime() >= today.getTime();

      let todayReviews = 0;
      let todayNew = 0;
      let correct = 0;
      let total = 0;
      let totalSecs = 0;

      // ç»Ÿè®¡æ•°æ®éªŒè¯å’Œè®¡ç®—
      for (const s of sessions) {
        if (!s || !s.startTime) continue;

        // ç´¯è®¡å­¦ä¹ æ—¶é—´ï¼ˆæ‰€æœ‰ä¼šè¯ï¼‰
        const sessionTime = s.totalTime || 0;
        if (typeof sessionTime === 'number' && sessionTime > 0) {
          totalSecs += sessionTime;
        }

        // ä»Šæ—¥æ•°æ®ç»Ÿè®¡
        if (isToday(s.startTime)) {
          const cardsReviewed = Math.max(0, s.cardsReviewed || 0);
          const newCards = Math.max(0, s.newCardsLearned || 0);
          const correctAnswers = Math.max(0, s.correctAnswers || 0);

          todayReviews += cardsReviewed;
          todayNew += newCards;
          correct += correctAnswers;
          total += cardsReviewed;
        }
      }

      const accuracy = total > 0 ? Math.round((correct / total) * 100) : 0;
      const totalStudyMins = Math.round((totalSecs || 0) / 60);

      // æ”¹è¿›çš„è¿ç»­å­¦ä¹ å¤©æ•°è®¡ç®—
      let streak = 0;
      let cursor = new Date();
      cursor.setHours(0, 0, 0, 0);

      const hasSessionsOn = (day: Date) => sessions.some((s: any) => {
        if (!s.startTime || !s.cardsReviewed || s.cardsReviewed <= 0) return false;
        const d = new Date(s.startTime);
        d.setHours(0, 0, 0, 0);
        return d.getTime() === day.getTime();
      });

      while (hasSessionsOn(cursor)) {
        streak++;
        cursor.setDate(cursor.getDate() - 1);
      }

      // approximate memory rate: average of last 7 days accuracy
      let last7Correct = 0, last7Total = 0;
      const since7 = new Date(); since7.setDate(since7.getDate()-7); since7.setHours(0,0,0,0);
      for (const s of sessions) {
        const d = new Date(s.startTime); if (d >= since7) { last7Correct += s.correctAnswers||0; last7Total += s.cardsReviewed||0; }
      }
      const memoryRate = last7Total>0 ? Math.round((last7Correct/last7Total)*100) : accuracy;

      // FSRSè¿›åº¦è®¡ç®— - æ›´å‡†ç¡®çš„å®ç°
      const validCards = cards.filter(c => c && c.fsrs);
      const learnedCards = validCards.filter(c => {
        // æ£€æŸ¥å¡ç‰‡æ˜¯å¦å·²ç»å­¦ä¹ è¿‡ï¼ˆä¸æ˜¯æ–°å¡ç‰‡çŠ¶æ€ï¼‰
        return c.fsrs.state !== 0 && // ä¸æ˜¯æ–°å¡ç‰‡
               c.reviewHistory &&
               c.reviewHistory.length > 0; // æœ‰å¤ä¹ å†å²
      });

      const fsrsProgress = validCards.length > 0 ?
        Math.round((learnedCards.length / validCards.length) * 100) : 0;

      kpi = {
        todayReviews, todayNew, accuracy, totalStudyMins,
        memoryRate, streakDays: streak, fsrsProgress
      };
      await reloadCharts();
    } catch (error) {
      console.error('Error loading analytics data:', error);
      hasError = true;
      errorMessage = error instanceof Error ? error.message : 'åŠ è½½æ•°æ®æ—¶å‘ç”ŸæœªçŸ¥é”™è¯¯';
    } finally {
      isLoading = false;
    }
  })();

  // æ•°æ®æ ¼å¼åŒ–å‡½æ•°
  function formatNumber(n: number): string {
    if (typeof n !== 'number' || isNaN(n)) return '0';
    return new Intl.NumberFormat().format(n);
  }

  function formatPercentage(n: number): string {
    if (typeof n !== 'number' || isNaN(n)) return '0%';
    return `${Math.round(n)}%`;
  }

  function formatTime(minutes: number): string {
    if (typeof minutes !== 'number' || isNaN(minutes) || minutes < 0) return '0m';

    if (minutes < 60) {
      return `${Math.round(minutes)}m`;
    } else {
      const hours = Math.floor(minutes / 60);
      const remainingMinutes = Math.round(minutes % 60);
      return remainingMinutes > 0 ? `${hours}h ${remainingMinutes}m` : `${hours}h`;
    }
  }
  function setRange(v: typeof range) {
    const startTime = performance.now();

    // è®°å½•ç”¨æˆ·è¡Œä¸ºç”¨äºé¢„åŠ è½½é¢„æµ‹
    smartPreloader.recordBehavior('range-change', {
      fromRange: range,
      toRange: v,
      selectedDecks: selectedDecks.length,
      timestamp: Date.now()
    });

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    smartCache.deleteByTag('analytics');
    smartCache.deleteByTag(`range-${range}`);

    range = v;
    reloadCharts();

    // é¢„æµ‹å¹¶é¢„åŠ è½½ä¸‹ä¸€æ­¥å¯èƒ½éœ€è¦çš„æ•°æ®
    const predictions = smartPreloader.predictNextActions('range-change', { range: v });
    if (predictions.length > 0) {
      setTimeout(() => {
        smartPreloader.triggerPreload(predictions);
      }, 500); // å»¶è¿Ÿé¢„åŠ è½½ï¼Œé¿å…å½±å“å½“å‰æ“ä½œ
    }

    const duration = performance.now() - startTime;
    // performanceMonitor.measure('user-interaction-range-change', () => {}, {
    //   range: v,
    //   duration
    // });
  }
  function toggleDeckDd(e?: Event) { if (e) e.stopPropagation(); deckDdOpen = !deckDdOpen; }
  function closeDeckDd() { deckDdOpen = false; }
  function deckIsSelected(id: string) { return selectedDecks.includes(id); }
  function deckToggle(id: string) {
    const startTime = performance.now();

    // è®°å½•ç”¨æˆ·è¡Œä¸º
    smartPreloader.recordBehavior('deck-toggle', {
      deckId: id,
      previousSelection: [...selectedDecks],
      action: selectedDecks.includes(id) ? 'remove' : 'add',
      range: range,
      timestamp: Date.now()
    });

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    smartCache.deleteByTag('analytics');
    smartCache.deleteByTag('dashboard-data');

    const set = new Set(selectedDecks);
    if (set.has(id)) set.delete(id); else set.add(id);
    selectedDecks = Array.from(set);
    reloadCharts();

    // é¢„æµ‹ç”¨æˆ·å¯èƒ½çš„ä¸‹ä¸€æ­¥æ“ä½œ
    const predictions = smartPreloader.predictNextActions('deck-toggle', {
      selectedDecks,
      range
    });
    if (predictions.length > 0) {
      setTimeout(() => {
        smartPreloader.triggerPreload(predictions);
      }, 300);
    }

    const duration = performance.now() - startTime;
    // performanceMonitor.measure('user-interaction-deck-toggle', () => {}, {
    //   deckId: id,
    //   selectedCount: selectedDecks.length,
    //   duration
    // });
  }
  function deckClearAll() {
    const startTime = performance.now();

    // è®°å½•ç”¨æˆ·è¡Œä¸º
    smartPreloader.recordBehavior('deck-clear-all', {
      previousSelection: [...selectedDecks],
      range: range,
      timestamp: Date.now()
    });

    // æ¸…é™¤ç›¸å…³ç¼“å­˜
    smartCache.deleteByTag('analytics');
    smartCache.deleteByTag('dashboard-data');

    selectedDecks = [];
    reloadCharts();
    closeDeckDd();
    const duration = performance.now() - startTime;
    // performanceMonitor.measure('user-interaction-deck-clear', () => {}, {
    //   duration
    // });
  }

  /**
   * å¤„ç†å›¾è¡¨æ‚¬åœäº‹ä»¶
   */
  function handleChartHover(chartType: string, dataPoint?: any) {
    smartPreloader.recordBehavior('chart-hover', {
      chartType,
      dataPoint: dataPoint ? JSON.stringify(dataPoint) : null,
      range,
      selectedDecks: selectedDecks.length,
      timestamp: Date.now()
    });
  }

  /**
   * å¤„ç†å›¾è¡¨ç‚¹å‡»äº‹ä»¶
   */
  function handleChartClick(chartType: string, dataPoint?: any) {
    smartPreloader.recordBehavior('chart-click', {
      chartType,
      dataPoint: dataPoint ? JSON.stringify(dataPoint) : null,
      range,
      selectedDecks: selectedDecks.length,
      timestamp: Date.now()
    });

    // é¢„æµ‹ç”¨æˆ·å¯èƒ½éœ€è¦çš„è¯¦ç»†æ•°æ®
    const predictions = smartPreloader.predictNextActions('chart-click', {
      chartType,
      range
    });
    if (predictions.length > 0) {
      setTimeout(() => {
        smartPreloader.triggerPreload(predictions);
      }, 200);
    }
  }
  function deckLabel() {
    if (!selectedDecks.length) return 'å…¨éƒ¨ç‰Œç»„';
    if (selectedDecks.length === 1) return deckOptions.find(d=>d.id===selectedDecks[0])?.name || '1ä¸ªå·²é€‰';
    return `å·²é€‰${selectedDecks.length}ä¸ª`;
  }
  function exportCsv() {
    const rows: string[] = [];
    rows.push('date,trend_reviews');
    for (const p of dayTrend) rows.push(`${p.key},${p.value}`);
    const csv = rows.join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a'); a.href = url; a.download = 'analytics.csv'; a.click(); URL.revokeObjectURL(url);
  }
</script>

<svelte:window onclick={closeDeckDd} onkeydown={(e) => { if (e.key==='Escape') closeDeckDd(); }} />

{#if hasError}
  <div class="error-container">
    <div class="error-icon">âš ï¸</div>
    <h3>{i18n.t('analytics.dashboard.error')}</h3>
    <p>{errorMessage}</p>
    <button class="retry-button" onclick={() => window.location.reload()}>
      {i18n.t('analytics.dashboard.retry')}
    </button>
  </div>
{:else}
  <div class="anki-app analytics-page" class:loading={isLoading}>
    {#if isLoading}
      <div class="loading-overlay">
        <div class="loading-content">
          <div class="loading-spinner"></div>
          <p class="loading-text">{i18n.t('analytics.dashboard.loading')}</p>
          <div class="loading-progress">
            <div class="progress-bar">
              <div class="progress-fill"></div>
            </div>
            <p class="progress-text">æ­£åœ¨å¤„ç†æ•°æ®...</p>
          </div>
        </div>
      </div>
    {/if}

    <h1>{i18n.t('analytics.dashboard.title')}</h1>

  <!-- Filter Bar -->
  <section class="filter-bar">
    <div class="group">
      <span id="range-label" class="group-label">æ—¶é—´èŒƒå›´</span>
      <div class="seg" role="group" aria-labelledby="range-label">
        <button class={range==='7'?'active':''} onclick={() => setRange('7')}>{i18n.t('analytics.timeRange.last7Days')}</button>
        <button class={range==='30'?'active':''} onclick={() => setRange('30')}>{i18n.t('analytics.timeRange.last30Days')}</button>
        <button class={range==='90'?'active':''} onclick={() => setRange('90')}>{i18n.t('analytics.timeRange.last90Days')}</button>
        <button class={range==='year'?'active':''} onclick={() => setRange('year')}>{i18n.t('analytics.timeRange.thisYear')}</button>
        <button class={range==='all'?'active':''} onclick={() => setRange('all')}>å…¨éƒ¨</button>
      </div>
    </div>
    <div class="group dd">
      <span id="deck-label" class="group-label">ç‰Œç»„</span>
      <button id="deck-dd-btn" class="dd-toggle" aria-haspopup="menu" aria-expanded={deckDdOpen} aria-labelledby="deck-label deck-dd-btn" onclick={(e)=>toggleDeckDd(e)}>{deckLabel()}</button>
      {#if deckDdOpen}
        <div class="dd-menu" role="menu" aria-labelledby="deck-label">
          <button class="dd-item" role="menuitem" onclick={deckClearAll}>å…¨éƒ¨ç‰Œç»„</button>
          <div class="dd-sep"></div>
          {#each deckOptions as d}
            <button class="dd-item" role="menuitemcheckbox" aria-checked={deckIsSelected(d.id)} onclick={() => deckToggle(d.id)}>
              <span class={deckIsSelected(d.id)?'check on':'check'}>âœ“</span>
              <span class="dd-text">{d.name}</span>
            </button>
          {/each}
        </div>
      {/if}
    </div>
    <div class="spacer"></div>
    <button class="btn" onclick={exportCsv}>{i18n.t('common.export')} CSV</button>
  </section>

  <!-- KPI Cards -->
  <section class="kpi-grid" aria-busy={isLoading}>
    <div class="kpi-card">
      <div class="kpi-head">
        <span class="kpi-title">{i18n.t('analytics.dashboard.kpi.todayReviews')}</span>
        <EnhancedIcon name="history" size="16" />
      </div>
      <div class="kpi-value">{formatNumber(kpi.todayReviews)}</div>
      <div class="kpi-sub">{i18n.t('analytics.dashboard.kpi.trend.yesterdayCompare')} <span class="trend up">+â€”</span></div>
      <div class="kpi-glow"></div>
    </div>

    <div class="kpi-card">
      <div class="kpi-head">
        <span class="kpi-title">{i18n.t('analytics.dashboard.kpi.todayNew')}</span>
        <EnhancedIcon name="plus" size="16" />
      </div>
      <div class="kpi-value">{formatNumber(kpi.todayNew)}</div>
      <div class="kpi-sub">{i18n.t('analytics.dashboard.kpi.trend.newCardsAdded')}</div>
      <div class="kpi-glow"></div>
    </div>

    <div class="kpi-card">
      <div class="kpi-head">
        <span class="kpi-title">{i18n.t('analytics.dashboard.kpi.accuracy')}</span>
        <EnhancedIcon name="check" size="16" />
      </div>
      <div class="kpi-value">{formatPercentage(kpi.accuracy)}</div>
      <div class="kpi-sub">è¿‘24å°æ—¶</div>
      <div class="kpi-glow"></div>
    </div>

    <div class="kpi-card">
      <div class="kpi-head">
        <span class="kpi-title">{i18n.t('analytics.dashboard.kpi.studyTime')}</span>
        <EnhancedIcon name="clock" size="16" />
      </div>
      <div class="kpi-value">{formatTime(kpi.totalStudyMins)}</div>
      <div class="kpi-sub">ç´¯è®¡ï¼ˆä¼šè¯ï¼‰</div>
      <div class="kpi-glow"></div>
    </div>

    <div class="kpi-card">
      <div class="kpi-head">
        <span class="kpi-title">{i18n.t('analytics.dashboard.kpi.memoryRate')}</span>
        <EnhancedIcon name="info" size="16" />
      </div>
      <div class="kpi-value">{formatPercentage(kpi.memoryRate)}</div>
      <div class="kpi-sub">è¿‘7å¤©</div>
      <div class="kpi-glow"></div>
    </div>

    <div class="kpi-card">
      <div class="kpi-head">
        <span class="kpi-title">{i18n.t('analytics.dashboard.kpi.streakDays')}</span>
        <EnhancedIcon name="statistics" size="16" />
      </div>
      <div class="kpi-value">{kpi.streakDays}</div>
      <div class="kpi-sub">è¿ç»­å­¦ä¹ </div>
      <div class="kpi-glow"></div>
    </div>

    <div class="kpi-card">
      <div class="kpi-head">
        <span class="kpi-title">{i18n.t('analytics.dashboard.kpi.fsrsProgress')}</span>
        <EnhancedIcon name="filter" size="16" />
      </div>
      <div class="kpi-value">{formatPercentage(kpi.fsrsProgress)}</div>
      <div class="kpi-sub">å·²å­¦ä¹ /å…¨éƒ¨</div>
      <div class="kpi-glow"></div>
    </div>
  </section>

  <!-- Charts -->
  <section class="panel-row">
    <div class="panel">
      <div class="panel-head"><span>{i18n.t('analytics.dashboard.charts.reviewTrend', { days: timeRangeConfig.DEFAULT_DAYS })}</span></div>
      <LineChart data={dayTrend} height={chartConfig.DEFAULT_HEIGHT} />
    </div>
    <div class="panel">
      <div class="panel-head"><span>{i18n.t('analytics.dashboard.charts.ratingDistribution')}</span></div>
      <BarChart data={ratingBars} height={chartConfig.DEFAULT_HEIGHT} />
    </div>
  </section>
  <section class="panel-row">
    <div class="panel">
      <div class="panel-head"><span>{i18n.t('analytics.dashboard.charts.calendarHeatmap')}</span></div>
      <CalendarHeatmap byDay={calMap} />
    </div>
    <div class="panel">
      <div class="panel-head"><span>{i18n.t('analytics.dashboard.charts.timeHeatmap')}</span></div>
      <Heatmap matrix={hoursMatrix} />
    </div>
  </section>
  <section class="panel-row">
    <div class="panel">
      <div class="panel-head"><span>{i18n.t('analytics.dashboard.charts.intervalGrowth')}</span></div>
      <LineChart data={intervalTrend} height={chartConfig.DEFAULT_HEIGHT} />
    </div>
    <div class="panel">
      <div class="panel-head"><span>{i18n.t('analytics.dashboard.charts.deckComparison')}</span></div>
      <div class="deck-table-container">
        <VirtualizedDataTable
          data={deckCompareData}
          columns={deckTableColumns}
          height={200}
          itemHeight={40}
          loading={isLoading}
          emptyText={i18n.t('analytics.dashboard.noData')}
          onRowClick={(row: any, index: number) => {
            console.log('Deck clicked:', row.name, 'at index:', index);
            // è¿™é‡Œå¯ä»¥æ·»åŠ ç‚¹å‡»ç‰Œç»„çš„å¤„ç†é€»è¾‘
            handleChartClick('deck-table', row);
          }}
          onSort={(column: any, direction: any) => {
            console.log('Sort by:', column, direction);
            // æ’åºé€»è¾‘å·²åœ¨ç»„ä»¶å†…éƒ¨å¤„ç†
          }}
        />
      </div>
    </div>
  </section>

  <!-- FSRS6 åˆ†æé¢æ¿ -->
  <section class="fsrs-section">
    <h2>{i18n.t('analytics.dashboard.fsrs.title')}</h2>

    <!-- æ–°çš„FSRSåˆ†æé¢æ¿ -->
    <FSRSAnalysisPanel {plugin} className="fsrs-analysis-main" />

    <!-- FSRS KPI å¡ç‰‡ -->
    <div class="fsrs-kpi-grid">
      <div class="kpi-card fsrs-kpi">
        <div class="kpi-head">
          <span class="kpi-title">{i18n.t('analytics.dashboard.fsrs.avgDifficulty')}</span>
          <EnhancedIcon name="trending-up" size="16" />
        </div>
        <div class="kpi-value">{fsrsKPI.avgDifficulty.toFixed(2)}</div>
        <div class="kpi-sub">{i18n.t('analytics.dashboard.fsrs.difficultyScore')}</div>
        <div class="kpi-glow"></div>
      </div>

      <div class="kpi-card fsrs-kpi">
        <div class="kpi-head">
          <span class="kpi-title">{i18n.t('analytics.dashboard.fsrs.avgStability')}</span>
          <EnhancedIcon name="shield" size="16" />
        </div>
        <div class="kpi-value">{fsrsKPI.avgStability.toFixed(1)}</div>
        <div class="kpi-sub">{i18n.t('analytics.dashboard.fsrs.stabilityDays')}</div>
        <div class="kpi-glow"></div>
      </div>

      <div class="kpi-card fsrs-kpi">
        <div class="kpi-head">
          <span class="kpi-title">{i18n.t('analytics.dashboard.fsrs.learningEfficiency')}</span>
          <EnhancedIcon name="zap" size="16" />
        </div>
        <div class="kpi-value">{fsrsKPI.algorithmEfficiency.toFixed(1)}%</div>
        <div class="kpi-sub">é¢„æµ‹å‡†ç¡®æ€§</div>
        <div class="kpi-glow"></div>
      </div>

      <div class="kpi-card fsrs-kpi">
        <div class="kpi-head">
          <span class="kpi-title">æˆç†Ÿå¡ç‰‡</span>
          <EnhancedIcon name="check-circle" size="16" />
        </div>
        <div class="kpi-value">{fsrsKPI.matureCards}</div>
        <div class="kpi-sub">/ {fsrsKPI.totalCards} æ€»æ•°</div>
        <div class="kpi-glow"></div>
      </div>
    </div>

    <!-- FSRS å›¾è¡¨é¢æ¿ -->
    <div class="fsrs-charts">
      <!-- è®°å¿†æ›²çº¿å’Œéš¾åº¦åˆ†å¸ƒ -->
      <section class="panel-row">
        <div class="panel">
          <div class="panel-head">
            <span>è®°å¿†æ›²çº¿åˆ†æ</span>
            <div class="panel-controls">
              <span class="muted">å®é™… vs FSRS6é¢„æµ‹</span>
            </div>
          </div>
          <MemoryCurveChart data={memoryCurveData} height={250} />
        </div>

        <div class="panel">
          <div class="panel-head"><span>éš¾åº¦åˆ†å¸ƒ</span></div>
          <DifficultyDistributionChart data={difficultyData} height={250} />
        </div>
      </section>

      <!-- å‚æ•°å½±å“å’Œç®—æ³•å¯¹æ¯” -->
      <section class="panel-row">
        <div class="panel">
          <div class="panel-head"><span>å‚æ•°å½±å“åˆ†æ</span></div>
          <ParameterImpactRadar data={parameterImpact} height={280} />
        </div>

        <div class="panel">
          <div class="panel-head"><span>ç®—æ³•æ•ˆæœå¯¹æ¯”</span></div>
          <AlgorithmComparisonChart data={algorithmComparison} height={280} />
        </div>
      </section>
    </div>
  </section>
</div>

<style>
  .analytics-page { max-width: 1200px; margin: 0 auto; }
  h1 { font-size: 1.75rem; font-weight: 700; margin: 0 0 1.25rem 0; }

  .kpi-grid {
    display: grid; gap: 1rem; grid-template-columns: repeat(4, 1fr);
  }
  .filter-bar { display:flex; gap:1rem; align-items:center; background: var(--background-secondary); border:1px solid var(--background-modifier-border); border-radius:.75rem; padding:.75rem 1rem; margin-bottom:1rem; }
  .filter-bar .group { display:flex; gap:.5rem; align-items:center; }
  .filter-bar .group.dd { position: relative; }
  /* removed unused label style */
  .filter-bar .seg { display:flex; background: var(--background-primary); border:1px solid var(--background-modifier-border); border-radius:.5rem; overflow:hidden; }
  .filter-bar .seg button { padding:.4rem .75rem; background:transparent; border:none; color: var(--text-muted); cursor:pointer; }
  .filter-bar .seg button.active { background: linear-gradient(135deg, #8b5cf6, #6366f1); color:white; }
  .filter-bar .spacer { flex:1; }
  .filter-bar .btn { padding:.45rem .8rem; border:none; border-radius:.5rem; background:#0d0e14; color:#ececf2; border:1px solid var(--background-modifier-border); cursor:pointer; }

  .dd-toggle { padding:.4rem .75rem; background: var(--background-primary); border:1px solid var(--background-modifier-border); color: var(--text-normal); border-radius:.5rem; cursor:pointer; }
  .dd-menu { position:absolute; top: calc(100% + 8px); left:0; min-width: 220px; background: var(--background-primary); border:1px solid var(--background-modifier-border); border-radius:.5rem; box-shadow: 0 10px 20px rgba(0,0,0,.2); z-index: 20; padding:.35rem; }
  .dd-item { width:100%; text-align:left; background:transparent; border:none; color: var(--text-normal); padding:.45rem .5rem; border-radius:.35rem; cursor:pointer; display:flex; align-items:center; gap:.5rem; }
  .dd-item:hover { background: var(--background-modifier-hover); }
  .dd-sep { height:1px; background: var(--background-modifier-border); margin:.25rem 0; }
  .check { width:1rem; height:1rem; display:inline-flex; align-items:center; justify-content:center; border:1px solid var(--background-modifier-border); border-radius:.25rem; color: transparent; }
  .check.on { background: linear-gradient(135deg, #8b5cf6, #6366f1); border-color: transparent; color: white; }
  .dd-text { flex:1; }
  .kpi-card {
    position: relative;
    background: var(--background-secondary);
    border: 1px solid var(--background-modifier-border);
    border-radius: 1rem; padding: 1rem 1.25rem;
    overflow: hidden; transition: transform .18s ease, box-shadow .18s ease;
  }
  .kpi-card:hover { transform: translateY(-2px); box-shadow: 0 10px 20px rgba(0,0,0,.15); }
  .kpi-head { display: flex; align-items: center; justify-content: space-between; color: var(--text-muted); }
  .kpi-title { font-size: .9rem; font-weight: 600; }
  .kpi-value { font-size: 2rem; font-weight: 800; margin-top: .25rem; color: var(--text-normal); }
  .kpi-sub { color: var(--text-muted); font-size: .8rem; }
  .trend.up { color: #10b981; }
  .kpi-glow { position:absolute; inset:auto -20% -40% -20%; height: 60%; background: radial-gradient(60% 60% at 50% 0%, rgba(139,92,246,.18), transparent 70%); pointer-events:none; filter: blur(8px); }

  .panel-row {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 1rem;
    margin-top: 1rem;
    animation: slideInUp 0.4s ease-out;
  }

  .panel {
    background: var(--background-secondary);
    border: 1px solid var(--background-modifier-border);
    border-radius: .75rem;
    min-height: 260px;
    display: flex;
    flex-direction: column;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    animation: fadeInScale 0.3s ease-out;
  }

  .panel:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  }

  .panel-head {
    padding: .75rem 1rem;
    border-bottom: 1px solid var(--background-modifier-border);
    color: var(--text-muted);
    font-weight: 600;
    transition: color 0.2s ease;
  }

  .panel:hover .panel-head {
    color: var(--text-normal);
  }

  .panel :global(svg) {
    flex: 1;
    transition: opacity 0.3s ease;
  }
  .deck-table-container {
    padding: 0.5rem;
    flex: 1;
    display: flex;
    flex-direction: column;
  }

  /* åŠ¨ç”»å…³é”®å¸§ */
  @keyframes slideInUp {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  @keyframes fadeInScale {
    from {
      opacity: 0;
      transform: scale(0.95);
    }
    to {
      opacity: 1;
      transform: scale(1);
    }
  }

  @keyframes pulse {
    0%, 100% {
      opacity: 1;
    }
    50% {
      opacity: 0.7;
    }
  }

  /* åŠ è½½çŠ¶æ€åŠ¨ç”» */
  .loading .panel {
    animation: pulse 1.5s ease-in-out infinite;
  }

  .loading .kpi-card {
    animation: pulse 1.5s ease-in-out infinite;
  }

  /* å“åº”å¼è®¾è®¡ */
  @media (max-width: 1024px) {
    .kpi-grid { grid-template-columns: repeat(3, 1fr); }
    .panel-row { gap: 0.75rem; }
  }

  @media (max-width: 768px) {
    .kpi-grid { grid-template-columns: repeat(2, 1fr); }
    .panel-row { grid-template-columns: 1fr; gap: 0.5rem; }
    .panel { min-height: 220px; }
  }

  @media (max-width: 480px) {
    .kpi-grid { grid-template-columns: 1fr; }
    .panel { min-height: 200px; }
    .kpi-card { padding: 0.75rem 1rem; }
  }

  /* FSRS åˆ†æé¢æ¿æ ·å¼ */
  .fsrs-section {
    margin-top: 2rem;
    padding-top: 2rem;
    border-top: 2px solid var(--background-modifier-border);
  }

  .fsrs-section h2 {
    font-size: 1.5rem;
    font-weight: 700;
    margin: 0 0 1.5rem 0;
    color: var(--text-normal);
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .fsrs-section h2::before {
    content: "ğŸ§ ";
    font-size: 1.2rem;
  }

  .fsrs-analysis-main {
    margin-bottom: 2rem;
  }

  .fsrs-kpi-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 1rem;
    margin-bottom: 2rem;
  }

  .fsrs-kpi {
    background: linear-gradient(135deg, var(--background-secondary), var(--background-primary));
    border: 1px solid var(--interactive-accent);
    border-radius: 1rem;
    position: relative;
    overflow: hidden;
  }

  .fsrs-kpi .kpi-glow {
    background: radial-gradient(60% 60% at 50% 0%, rgba(99, 102, 241, 0.2), transparent 70%);
  }

  .fsrs-charts {
    display: flex;
    flex-direction: column;
    gap: 1.5rem;
  }

  .panel-controls {
    display: flex;
    align-items: center;
    gap: 1rem;
  }

  .panel-controls .muted {
    font-size: 0.875rem;
    color: var(--text-muted);
    font-weight: normal;
  }

  /* å“åº”å¼è®¾è®¡ */
  @media (max-width: 1024px) {
    .fsrs-kpi-grid {
      grid-template-columns: repeat(2, 1fr);
    }
  }

  @media (max-width: 768px) {
    .fsrs-kpi-grid {
      grid-template-columns: 1fr;
    }

    .fsrs-section h2 {
      font-size: 1.25rem;
    }
  }

  /* é”™è¯¯å’ŒåŠ è½½çŠ¶æ€æ ·å¼ */
  .error-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    min-height: 400px;
    text-align: center;
    color: var(--text-muted);
    background: var(--background-secondary);
    border-radius: 12px;
    border: 1px solid var(--background-modifier-border);
    margin: 20px;
    padding: 40px;
  }

  .error-icon {
    font-size: 3rem;
    margin-bottom: 16px;
  }

  .error-container h3 {
    margin: 0 0 12px 0;
    color: var(--text-normal);
    font-size: 1.2rem;
  }

  .error-container p {
    margin: 0 0 20px 0;
    line-height: 1.5;
  }

  .retry-button {
    background: var(--interactive-accent);
    color: white;
    border: none;
    border-radius: 6px;
    padding: 10px 20px;
    font-size: 0.9rem;
    cursor: pointer;
    transition: background-color 0.2s;
  }

  .retry-button:hover {
    background: var(--interactive-accent-hover);
  }

  .loading-overlay {
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(var(--background-primary-rgb), 0.95);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 1000;
    backdrop-filter: blur(4px);
    animation: fadeIn 0.3s ease-out;
  }

  .loading-content {
    background: var(--background-secondary);
    border-radius: 12px;
    padding: 2rem;
    text-align: center;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
    border: 1px solid var(--background-modifier-border);
    min-width: 280px;
  }

  .loading-spinner {
    width: 2.5rem;
    height: 2.5rem;
    border: 3px solid var(--background-modifier-border);
    border-top: 3px solid var(--interactive-accent);
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 1rem auto;
  }

  .loading-text {
    margin: 0 0 1rem 0;
    color: var(--text-normal);
    font-weight: 500;
    font-size: 1rem;
  }

  .loading-progress {
    margin-top: 1rem;
  }

  .progress-bar {
    width: 100%;
    height: 4px;
    background: var(--background-modifier-border);
    border-radius: 2px;
    overflow: hidden;
    margin-bottom: 0.5rem;
  }

  .progress-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--interactive-accent), var(--interactive-accent-hover));
    border-radius: 2px;
    animation: progressFill 2s ease-in-out infinite;
  }

  .progress-text {
    margin: 0;
    font-size: 0.875rem;
    color: var(--text-muted);
  }

  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  @keyframes progressFill {
    0% { width: 0%; }
    50% { width: 70%; }
    100% { width: 100%; }
  }

  .analytics-page.loading {
    position: relative;
    pointer-events: none;
  }
</style>

{/if}
