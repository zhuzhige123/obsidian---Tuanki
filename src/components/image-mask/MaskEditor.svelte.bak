<script lang="ts">
/**
 * Fabric.js é®ç½©ç¼–è¾‘å™¨ç»„ä»¶
 * 
 * åŠŸèƒ½ï¼š
 * - ä½¿ç”¨ Fabric.js æä¾›å›¾å½¢ç¼–è¾‘èƒ½åŠ›
 * - æ”¯æŒçŸ©å½¢å’Œåœ†å½¢é®ç½©ç»˜åˆ¶
 * - æ”¯æŒæ‹–æ‹½ã€ç¼©æ”¾ã€åˆ é™¤é®ç½©
 * - è‡ªåŠ¨è½¬æ¢ç›¸å¯¹åæ ‡å’Œåƒç´ åæ ‡
 */

import { onMount, onDestroy, tick } from 'svelte';
import { fabric } from 'fabric';
  import type { App, TFile } from 'obsidian';
  import type { Mask, MaskData } from '../../types/image-mask-types';
  import { MASK_CONSTANTS } from '../../types/image-mask-types';
  import { generateMaskId } from '../../services/image-mask/MaskDataParser';

// Props
let { 
  app,
  imageFile,
  initialMaskData = null,
  currentColor = 'rgba(0, 0, 0, 0.7)',
  currentOpacity = 70,
  onMaskDataChange,
  onEditorReady = () => {}
}: {
  app: App;
  imageFile: TFile;
  initialMaskData: MaskData | null;
  currentColor?: string;
  currentOpacity?: number;
  onMaskDataChange: (maskData: MaskData) => void;
  onEditorReady?: (ready: boolean) => void;
} = $props();

// çŠ¶æ€
let canvasElement = $state<HTMLCanvasElement | null>(null);
let fabricCanvas = $state<fabric.Canvas | null>(null);
let imageWidth = $state(0);
let imageHeight = $state(0);
let loading = $state(true);
let error = $state<string | null>(null);

// ç»˜åˆ¶æ¨¡å¼çŠ¶æ€
let drawingMode = $state<'rect' | 'circle' | null>(null);
let isDrawing = $state(false);
let drawStartPoint = $state<{ x: number; y: number } | null>(null);
let tempDrawingObject = $state<fabric.Object | null>(null);

// å·¥å…·æ çŠ¶æ€
let maskList = $state<Mask[]>([]);

onMount(async () => {
  console.log('[MaskEditor] ç»„ä»¶å·²æŒ‚è½½');
  
  // ç­‰å¾… DOM æ¸²æŸ“å®Œæˆï¼Œç¡®ä¿ canvas å…ƒç´ å·²ç»‘å®š
  await tick();
  
  // çŸ­æš‚å»¶è¿Ÿç¡®ä¿ç»‘å®šå®Œæˆï¼ˆCanvas ç°åœ¨å§‹ç»ˆåœ¨ DOM ä¸­ï¼‰
  await new Promise(resolve => setTimeout(resolve, 50));
  
  try {
    console.log('[MaskEditor] canvasElement ç»‘å®šçŠ¶æ€:', !!canvasElement);
    await initializeCanvas();
  } catch (err) {
    console.error('[MaskEditor] åˆå§‹åŒ–å¤±è´¥:', err);
    error = err instanceof Error ? err.message : 'åˆå§‹åŒ–å¤±è´¥';
    loading = false;
  }
});

onDestroy(() => {
  if (fabricCanvas) {
    fabricCanvas.dispose();
    fabricCanvas = null;
  }
});

/**
 * åˆå§‹åŒ– Canvas
 */
async function initializeCanvas() {
  console.log('[MaskEditor] å¼€å§‹åˆå§‹åŒ– Canvas...');
  console.log('[MaskEditor] canvasElement:', canvasElement);
  console.log('[MaskEditor] imageFile:', imageFile);
  
  if (!canvasElement) {
    const errorMsg = 'Canvas å…ƒç´ åˆå§‹åŒ–å¤±è´¥\n\nè¯·å°è¯•ï¼š\n1. å…³é—­å¹¶é‡æ–°æ‰“å¼€ç¼–è¾‘å™¨\n2. æ£€æŸ¥å›¾ç‰‡æ–‡ä»¶æ˜¯å¦å­˜åœ¨\n3. æŸ¥çœ‹æ§åˆ¶å°äº†è§£è¯¦ç»†ä¿¡æ¯';
    console.error('[MaskEditor]', errorMsg);
    console.error('[MaskEditor] DOM çŠ¶æ€:', {
      hasCanvasElement: !!canvasElement,
      hasImageFile: !!imageFile,
      imageFilePath: imageFile?.path
    });
    error = errorMsg;
    loading = false;
    return;
  }

  // åŠ è½½å›¾ç‰‡
  console.log('[MaskEditor] å¼€å§‹åŠ è½½å›¾ç‰‡:', imageFile.path);
  const imageData = await loadImage();
  if (!imageData) {
    error = 'æ— æ³•åŠ è½½å›¾ç‰‡';
    loading = false;
    return;
  }

  console.log('[MaskEditor] å›¾ç‰‡åŠ è½½æˆåŠŸ:', imageData.width, 'x', imageData.height);
  imageWidth = imageData.width;
  imageHeight = imageData.height;

  // åˆå§‹åŒ– Fabric.js Canvas
  console.log('[MaskEditor] åˆå§‹åŒ– Fabric.js Canvas...');
  fabricCanvas = new fabric.Canvas(canvasElement, {
    width: imageWidth,
    height: imageHeight,
    backgroundColor: '#f0f0f0'
  });

  // è®¾ç½®èƒŒæ™¯å›¾ç‰‡
  fabric.Image.fromURL(imageData.url, (img: fabric.Image) => {
    if (!fabricCanvas) return;
    
    img.scaleToWidth(imageWidth);
    img.scaleToHeight(imageHeight);
    img.selectable = false;
    img.evented = false;
    
    fabricCanvas.setBackgroundImage(img, fabricCanvas.renderAll.bind(fabricCanvas));
    
    // åŠ è½½ç°æœ‰é®ç½©
    if (initialMaskData) {
      loadMasksToCanvas(initialMaskData);
    }
    
    loading = false;
  });

  // ç›‘å¬å¯¹è±¡ä¿®æ”¹äº‹ä»¶
  fabricCanvas.on('object:modified', handleObjectModified);
  fabricCanvas.on('selection:cleared', handleSelectionCleared);
  
  // ç›‘å¬é¼ æ ‡äº‹ä»¶ç”¨äºæ‹–æ‹½ç»˜åˆ¶
  fabricCanvas.on('mouse:down', handleMouseDown);
  fabricCanvas.on('mouse:move', handleMouseMove);
  fabricCanvas.on('mouse:up', handleMouseUp);
  
  console.log('[MaskEditor] Canvas åˆå§‹åŒ–å®Œæˆ');
  
  // é€šçŸ¥çˆ¶ç»„ä»¶ç¼–è¾‘å™¨å·²å°±ç»ª
  onEditorReady(true);
}

/**
 * åŠ è½½å›¾ç‰‡
 */
async function loadImage(): Promise<{url: string; width: number; height: number} | null> {
  try {
    // è·å–å›¾ç‰‡èµ„æºè·¯å¾„
    const resourcePath = app.vault.adapter.getResourcePath(imageFile.path);
    
    // åŠ è½½å›¾ç‰‡ä»¥è·å–å°ºå¯¸
    return new Promise((resolve, reject) => {
      const img = new Image();
      
      img.onload = () => {
        resolve({
          url: resourcePath,
          width: img.width,
          height: img.height
        });
      };
      
      img.onerror = () => {
        reject(new Error('å›¾ç‰‡åŠ è½½å¤±è´¥'));
      };
      
      img.src = resourcePath;
    });
    
  } catch (error) {
    console.error('[MaskEditor] åŠ è½½å›¾ç‰‡å¤±è´¥:', error);
    return null;
  }
}

/**
 * åŠ è½½é®ç½©åˆ° Canvas
 */
function loadMasksToCanvas(maskData: MaskData) {
  if (!fabricCanvas) return;
  
  maskData.masks.forEach(mask => {
    const obj = relativeToFabric(mask);
    if (obj) {
      fabricCanvas!.add(obj);
      maskList.push(mask);
    }
  });
  
  fabricCanvas.renderAll();
}

/**
 * å¯ç”¨çŸ©å½¢ç»˜åˆ¶æ¨¡å¼ï¼ˆå…¬å…±æ–¹æ³•ï¼Œä¾›çˆ¶ç»„ä»¶è°ƒç”¨ï¼‰
 */
export function enableRectDrawing() {
  if (!fabricCanvas) return;
  
  console.log('[MaskEditor] å¯ç”¨çŸ©å½¢ç»˜åˆ¶æ¨¡å¼');
  drawingMode = 'rect';
  
  // è®¾ç½®Canvaså…‰æ ‡ä¸ºåå­—
  fabricCanvas.defaultCursor = 'crosshair';
  fabricCanvas.hoverCursor = 'crosshair';
  
  // ç¦ç”¨å¯¹è±¡é€‰æ‹©ï¼Œä¸“æ³¨äºç»˜åˆ¶
  fabricCanvas.selection = false;
  fabricCanvas.forEachObject((obj) => {
    obj.selectable = false;
  });
}

/**
 * å¯ç”¨åœ†å½¢ç»˜åˆ¶æ¨¡å¼ï¼ˆå…¬å…±æ–¹æ³•ï¼Œä¾›çˆ¶ç»„ä»¶è°ƒç”¨ï¼‰
 */
export function enableCircleDrawing() {
  if (!fabricCanvas) return;
  
  console.log('[MaskEditor] å¯ç”¨åœ†å½¢ç»˜åˆ¶æ¨¡å¼');
  drawingMode = 'circle';
  
  // è®¾ç½®Canvaså…‰æ ‡ä¸ºåå­—
  fabricCanvas.defaultCursor = 'crosshair';
  fabricCanvas.hoverCursor = 'crosshair';
  
  // ç¦ç”¨å¯¹è±¡é€‰æ‹©ï¼Œä¸“æ³¨äºç»˜åˆ¶
  fabricCanvas.selection = false;
  fabricCanvas.forEachObject((obj) => {
    obj.selectable = false;
  });
}

/**
 * åˆ é™¤é€‰ä¸­çš„é®ç½©ï¼ˆå…¬å…±æ–¹æ³•ï¼Œä¾›çˆ¶ç»„ä»¶è°ƒç”¨ï¼‰
 */
export function deleteSelectedMask() {
  if (!fabricCanvas) return;
  
  const activeObject = fabricCanvas.getActiveObject();
  if (!activeObject) return;
  
  const maskId = (activeObject as any).data?.maskId;
  
  fabricCanvas.remove(activeObject);
  fabricCanvas.renderAll();
  
  // ä»åˆ—è¡¨ä¸­ç§»é™¤
  if (maskId) {
    maskList = maskList.filter(m => m.id !== maskId);
  }
  
  emitMaskDataChange();
}

/**
 * æ›´æ–°é€‰ä¸­é®ç½©çš„é¢œè‰²ï¼ˆå…¬å…±æ–¹æ³•ï¼Œä¾›çˆ¶ç»„ä»¶è°ƒç”¨ï¼‰
 */
export function updateSelectedMaskColor(newColor: string) {
  if (!fabricCanvas) return;
  
  const activeObject = fabricCanvas.getActiveObject();
  if (!activeObject) {
    console.log('[MaskEditor] æ²¡æœ‰é€‰ä¸­çš„é®ç½©');
    return;
  }
  
  const maskId = (activeObject as any).data?.maskId;
  
  // æ›´æ–°Fabricå¯¹è±¡çš„é¢œè‰²
  activeObject.set('fill', newColor);
  fabricCanvas.renderAll();
  
  // æ›´æ–°é®ç½©åˆ—è¡¨ä¸­çš„æ•°æ®
  if (maskId) {
    const index = maskList.findIndex(m => m.id === maskId);
    if (index >= 0) {
      maskList[index] = {
        ...maskList[index],
        fill: newColor
      };
      emitMaskDataChange();
      console.log('[MaskEditor] å·²æ›´æ–°é®ç½©é¢œè‰²:', newColor);
    }
  }
}

/**
 * ç›¸å¯¹åæ ‡ â†’ Fabric.js åƒç´ åæ ‡
 */
function relativeToFabric(mask: Mask): fabric.Object | null {
  if (mask.type === 'rect') {
    const rect = new fabric.Rect({
      left: mask.x * imageWidth,
      top: mask.y * imageHeight,
      width: mask.width! * imageWidth,
      height: mask.height! * imageHeight,
      fill: mask.fill || currentColor,
      strokeWidth: 2,
      stroke: '#4CAF50'
    });
    
    rect.set('data', { maskId: mask.id, maskType: 'rect' });
    return rect;
  }
  
  if (mask.type === 'circle') {
    const circle = new fabric.Circle({
      left: (mask.x - mask.radius!) * imageWidth,
      top: (mask.y - mask.radius!) * imageHeight,
      radius: mask.radius! * imageWidth,
      fill: mask.fill || currentColor,
      strokeWidth: 2,
      stroke: '#2196F3'
    });
    
    circle.set('data', { maskId: mask.id, maskType: 'circle' });
    return circle;
  }
  
  return null;
}

/**
 * Fabric.js åƒç´ åæ ‡ â†’ ç›¸å¯¹åæ ‡
 */
function fabricToRelative(obj: fabric.Object): Mask {
  const data = (obj as any).data || {};
  const maskType = data.maskType || 'rect';
  
  if (maskType === 'rect') {
    const rect = obj as fabric.Rect;
    return {
      id: data.maskId || generateMaskId(),
      type: 'rect',
      x: (rect.left || 0) / imageWidth,
      y: (rect.top || 0) / imageHeight,
      width: (rect.width || 0) * (rect.scaleX || 1) / imageWidth,
      height: (rect.height || 0) * (rect.scaleY || 1) / imageHeight,
      style: 'solid',
      fill: rect.fill as string || currentColor
    };
  }
  
  if (maskType === 'circle') {
    const circle = obj as fabric.Circle;
    const radius = (circle.radius || 0) * (circle.scaleX || 1) / imageWidth;
    return {
      id: data.maskId || generateMaskId(),
      type: 'circle',
      x: ((circle.left || 0) / imageWidth) + radius,
      y: ((circle.top || 0) / imageHeight) + radius,
      radius,
      style: 'solid',
      fill: circle.fill as string || currentColor
    };
  }
  
  // é»˜è®¤è¿”å›çŸ©å½¢
  return {
    id: generateMaskId(),
    type: 'rect',
    x: 0.25,
    y: 0.25,
    width: 0.5,
    height: 0.5,
    style: 'solid',
    fill: currentColor
  };
}

/**
 * å¤„ç†å¯¹è±¡ä¿®æ”¹äº‹ä»¶
 */
function handleObjectModified(e: any) {
  const obj = e.target;
  if (!obj) return;
  
  const data = (obj as any).data || {};
  const maskId = data.maskId;
  
  if (!maskId) return;
  
  // æ›´æ–°é®ç½©åˆ—è¡¨
  const updatedMask = fabricToRelative(obj);
  const index = maskList.findIndex(m => m.id === maskId);
  
  if (index >= 0) {
    maskList[index] = updatedMask;
  }
  
  emitMaskDataChange();
}

/**
 * å¤„ç†é€‰æ‹©æ¸…é™¤äº‹ä»¶
 */
function handleSelectionCleared() {
  // æ¸…ç©ºç»˜åˆ¶æ¨¡å¼
  if (!isDrawing) {
    drawingMode = null;
    if (fabricCanvas) {
      fabricCanvas.defaultCursor = 'default';
      fabricCanvas.hoverCursor = 'move';
      fabricCanvas.selection = true;
      fabricCanvas.forEachObject((obj) => {
        obj.selectable = true;
      });
    }
  }
}

/**
 * å¤„ç†é¼ æ ‡æŒ‰ä¸‹äº‹ä»¶ - å¼€å§‹ç»˜åˆ¶
 */
function handleMouseDown(event: fabric.IEvent) {
  if (!fabricCanvas || !drawingMode) return;
  
  const pointer = fabricCanvas.getPointer(event.e);
  
  // è®°å½•èµ·å§‹ç‚¹
  drawStartPoint = { x: pointer.x, y: pointer.y };
  isDrawing = true;
  
  console.log('[MaskEditor] å¼€å§‹ç»˜åˆ¶', drawingMode, drawStartPoint);
  
  // åˆ›å»ºä¸´æ—¶é¢„è§ˆå¯¹è±¡
  if (drawingMode === 'rect') {
    const rect = new fabric.Rect({
      left: drawStartPoint.x,
      top: drawStartPoint.y,
      width: 0,
      height: 0,
      fill: currentColor,
      strokeWidth: 2,
      stroke: '#4CAF50',
      selectable: false,
      evented: false
    });
    tempDrawingObject = rect;
    fabricCanvas.add(rect);
  } else if (drawingMode === 'circle') {
    const circle = new fabric.Circle({
      left: drawStartPoint.x,
      top: drawStartPoint.y,
      radius: 0,
      fill: currentColor,
      strokeWidth: 2,
      stroke: '#2196F3',
      selectable: false,
      evented: false
    });
    tempDrawingObject = circle;
    fabricCanvas.add(circle);
  }
}

/**
 * å¤„ç†é¼ æ ‡ç§»åŠ¨äº‹ä»¶ - åŠ¨æ€è°ƒæ•´ç»˜åˆ¶ä¸­çš„å¯¹è±¡
 */
function handleMouseMove(event: fabric.IEvent) {
  if (!fabricCanvas || !isDrawing || !drawStartPoint || !tempDrawingObject) return;
  
  const pointer = fabricCanvas.getPointer(event.e);
  
  if (drawingMode === 'rect' && tempDrawingObject instanceof fabric.Rect) {
    // è®¡ç®—çŸ©å½¢çš„ä½ç½®å’Œå°ºå¯¸ï¼ˆæ”¯æŒåå‘æ‹–æ‹½ï¼‰
    const left = Math.min(pointer.x, drawStartPoint.x);
    const top = Math.min(pointer.y, drawStartPoint.y);
    const width = Math.abs(pointer.x - drawStartPoint.x);
    const height = Math.abs(pointer.y - drawStartPoint.y);
    
    // é™åˆ¶åœ¨å›¾ç‰‡èŒƒå›´å†…
    tempDrawingObject.set({
      left: Math.max(0, Math.min(left, imageWidth)),
      top: Math.max(0, Math.min(top, imageHeight)),
      width: Math.min(width, imageWidth - left),
      height: Math.min(height, imageHeight - top)
    });
  } else if (drawingMode === 'circle' && tempDrawingObject instanceof fabric.Circle) {
    // è®¡ç®—åœ†å½¢çš„åŠå¾„ï¼ˆä»èµ·å§‹ç‚¹åˆ°å½“å‰ç‚¹çš„è·ç¦»ï¼‰
    const dx = pointer.x - drawStartPoint.x;
    const dy = pointer.y - drawStartPoint.y;
    const radius = Math.sqrt(dx * dx + dy * dy);
    
    // é™åˆ¶åŠå¾„ä¸è¶…å‡ºå›¾ç‰‡è¾¹ç•Œ
    const maxRadius = Math.min(
      drawStartPoint.x,
      drawStartPoint.y,
      imageWidth - drawStartPoint.x,
      imageHeight - drawStartPoint.y
    );
    
    tempDrawingObject.set({
      radius: Math.min(radius, maxRadius)
    });
  }
  
  fabricCanvas.renderAll();
}

/**
 * å¤„ç†é¼ æ ‡æ¾å¼€äº‹ä»¶ - å®Œæˆç»˜åˆ¶
 */
function handleMouseUp(event: fabric.IEvent) {
  if (!fabricCanvas || !isDrawing || !tempDrawingObject) return;
  
  console.log('[MaskEditor] å®Œæˆç»˜åˆ¶');
  
  // æ£€æŸ¥å¯¹è±¡æ˜¯å¦æœ‰æœ‰æ•ˆå°ºå¯¸ï¼ˆé¿å…åˆ›å»ºè¿‡å°çš„é®ç½©ï¼‰
  let isValidSize = false;
  
  if (tempDrawingObject instanceof fabric.Rect) {
    const width = tempDrawingObject.width || 0;
    const height = tempDrawingObject.height || 0;
    isValidSize = width > 10 && height > 10;
  } else if (tempDrawingObject instanceof fabric.Circle) {
    const radius = tempDrawingObject.radius || 0;
    isValidSize = radius > 5;
  }
  
  if (isValidSize) {
    // è®¾ç½®ä¸ºå¯é€‰æ‹©å’Œå¯ç¼–è¾‘
    tempDrawingObject.set({
      selectable: true,
      evented: true
    });
    
    // ç”Ÿæˆé®ç½©IDå¹¶å­˜å‚¨
    const maskId = generateMaskId();
    const maskType = drawingMode;
    tempDrawingObject.set('data', { maskId, maskType });
    
    // æ·»åŠ åˆ°é®ç½©åˆ—è¡¨
    const mask = fabricToRelative(tempDrawingObject);
    maskList.push(mask);
    
    // é€‰ä¸­æ–°åˆ›å»ºçš„é®ç½©
    fabricCanvas.setActiveObject(tempDrawingObject);
    
    // è§¦å‘æ•°æ®å˜æ›´
    emitMaskDataChange();
  } else {
    // å°ºå¯¸å¤ªå°ï¼Œç§»é™¤ä¸´æ—¶å¯¹è±¡
    fabricCanvas.remove(tempDrawingObject);
  }
  
  // æ¸…ç†ç»˜åˆ¶çŠ¶æ€
  isDrawing = false;
  drawStartPoint = null;
  tempDrawingObject = null;
  
  fabricCanvas.renderAll();
}

/**
 * è§¦å‘é®ç½©æ•°æ®å˜æ›´äº‹ä»¶
 */
function emitMaskDataChange() {
  const maskData: MaskData = {
    version: MASK_CONSTANTS.CURRENT_VERSION,
    masks: maskList
  };
  
  onMaskDataChange(maskData);
}

/**
 * è·å–å½“å‰é®ç½©æ•°æ®
 */
export function getMaskData(): MaskData {
  return {
    version: MASK_CONSTANTS.CURRENT_VERSION,
    masks: maskList
  };
}
</script>

<div class="mask-editor-container">
  <!-- Canvas ç¼–è¾‘åŒºï¼šå§‹ç»ˆåœ¨ DOM ä¸­ -->
  <div class="canvas-wrapper">
    <canvas bind:this={canvasElement}></canvas>
  </div>
  
  <!-- æç¤ºä¿¡æ¯ -->
  <div class="hint" style:opacity={loading || error ? '0' : '1'}>
    ğŸ’¡ æç¤ºï¼šé€‰æ‹©å·¥å…·ååœ¨å›¾ç‰‡ä¸Šæ‹–æ‹½ç»˜åˆ¶é®ç½©ï¼Œæ‹–æ‹½è°ƒæ•´ä½ç½®å’Œå¤§å°ï¼ŒåŒå‡»åˆ é™¤
  </div>
  
  <!-- åŠ è½½çŠ¶æ€è¦†ç›–å±‚ -->
  {#if loading}
    <div class="loading-overlay">
      <div class="spinner"></div>
      <p>åŠ è½½å›¾ç‰‡ä¸­...</p>
    </div>
  {/if}
  
  <!-- é”™è¯¯çŠ¶æ€è¦†ç›–å±‚ -->
  {#if error}
    <div class="error-overlay">
      <div class="error-icon">âŒ</div>
      <div class="error-content">
        <h3>åˆå§‹åŒ–å¤±è´¥</h3>
        {#each error.split('\n') as line}
          <p>{line}</p>
        {/each}
      </div>
    </div>
  {/if}
</div>

<style>
.mask-editor-container {
  position: relative;  /* ä¸ºè¦†ç›–å±‚æä¾›å®šä½ä¸Šä¸‹æ–‡ */
  display: flex;
  flex-direction: column;
  height: 100%;
  gap: 12px;
}

.loading-overlay, .error-overlay {
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: var(--background-primary);
  z-index: 10;
  gap: 12px;
}

.error-overlay {
  gap: 20px;
  padding: 40px;
  text-align: center;
}

.error-icon {
  font-size: 48px;
}

.error-content h3 {
  font-size: 20px;
  font-weight: 600;
  color: var(--text-error);
  margin-bottom: 16px;
}

.error-content p {
  color: var(--text-muted);
  line-height: 1.6;
  margin: 4px 0;
}

.spinner {
  width: 40px;
  height: 40px;
  border: 4px solid var(--background-modifier-border);
  border-top-color: var(--interactive-accent);
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

.canvas-wrapper {
  flex: 1;
  display: flex;
  align-items: center;
  justify-content: center;
  overflow: auto;
  background: var(--background-secondary);
  border-radius: 8px;
  border: 1px solid var(--background-modifier-border);
  padding: 16px;
}

canvas {
  max-width: 100%;
  max-height: 100%;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
}

.hint {
  padding: 12px;
  background: var(--background-secondary);
  border-radius: 8px;
  border: 1px solid var(--background-modifier-border);
  font-size: 13px;
  color: var(--text-muted);
  text-align: center;
}
</style>

